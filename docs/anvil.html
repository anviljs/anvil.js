<!DOCTYPE html><head><style type="text/css">pre code{display:block;padding:.5em;color:black;background:#f8f8ff}pre .comment,pre .template_comment,pre .diff .header,pre .javadoc{color:#998;font-style:italic}pre .keyword,pre .css .rule .keyword,pre .winutils,pre .javascript .title,pre .lisp .title,pre .subst{color:black;font-weight:bold}pre .number,pre .hexcolor{color:#40a070}pre .string,pre .tag .value,pre .phpdoc,pre .tex .formula{color:#d14}pre .title,pre .id{color:#900;font-weight:bold}pre .javascript .title,pre .lisp .title,pre .subst{font-weight:normal}pre .class .title,pre .haskell .label,pre .tex .command{color:#458;font-weight:bold}pre .tag,pre .tag .title,pre .rules .property,pre .django .tag .keyword{color:navy;font-weight:normal}pre .attribute,pre .variable,pre .instancevar,pre .lisp .body{color:teal}pre .regexp{color:#009926}pre .class{color:#458;font-weight:bold}pre .symbol,pre .ruby .symbol .string,pre .ruby .symbol .keyword,pre .ruby .symbol .keymethods,pre .lisp .keyword,pre .tex .special,pre .input_number{color:#990073}pre .builtin,pre .built_in,pre .lisp .title{color:#0086b3}pre .preprocessor,pre .pi,pre .doctype,pre .shebang,pre .cdata{color:#999;font-weight:bold}pre .deletion{background:#fdd}pre .addition{background:#dfd}pre .diff .change{background:#0086b3}pre .chunk{color:#aaa}pre .tex .formula{opacity:.5}#docs {margin:auto}.block {clear:both}.comment {padding: 0 10px;width:50%;background:snow}.code {width:49%;background:#f8f8ff}td {vertical-align:top}table {width:90%; border-collapse:collapse}</style></head><body><table id="docs"><tr class="block"><td class="comment"><p>Node's event emitter for all engines.</p></td><td class="code"><pre><code>events = require(<span class="string">"events"</span>)
emitter = events.EventEmitter
</code></pre></td></tr><tr class="block"><td class="comment"><p>JavaScript's functional programming helper library -- <br />See <a href='http://documentcloud.github.com/underscore'>http://documentcloud.github.com/underscore</a> for more info</p></td><td class="code"><pre><code>_ = require <span class="string">"underscore"</span>
</code></pre></td></tr><tr class="block"><td class="comment"><p>Console colors for Node -- <br />See <a href='https://github.com/Marak/colors.js'>https://github.com/Marak/colors.js</a> for more info</p></td><td class="code"><pre><code>colors = require <span class="string">"colors"</span>
</code></pre></td></tr><tr class="block"><td class="comment"><p>Filesystem API</p></td><td class="code"><pre><code>fs = require <span class="string">"fs"</span>
</code></pre></td></tr><tr class="block"><td class="comment"><p>Recursive mkdir for Node (think <em>mkdir -p</em>) -- <br />See ://github.com/substack/node-mkdirp for more info</p></td><td class="code"><pre><code>mkdir = require( <span class="string">"mkdirp"</span> ).mkdirp
</code></pre></td></tr><tr class="block"><td class="comment"><p>Node's path helper library</p></td><td class="code"><pre><code>path = require <span class="string">"path"</span>
</code></pre></td></tr><tr class="block"><td class="comment"><p>A Sinatra inspired web development framework for Node -- <br />See <a href='http://expressjs.com'>http://expressjs.com</a> for more info</p></td><td class="code"><pre><code>express = require <span class="string">"express"</span>
<span class="keyword">class</span> Log
</code></pre></td></tr><tr class="block"><td class="comment"><h2>onEvent</h2>

<p>Logs events in default console color</p>

<h3>Args:</h3>

<ul>
<li><em>x {String}</em>: message to log</li>
</ul></td><td class="code"><pre><code>	onEvent: (x) ->
		<span class="keyword">unless</span> quiet
			console.log <span class="string">"   <span class="subst">#{x}</span>"</span>

</code></pre></td></tr><tr class="block"><td class="comment"><h2>onStep</h2>

<p>Logs steps in blue</p>

<h3>Args:</h3>

<ul>
<li><em>x {String}</em>: message to log</li>
</ul></td><td class="code"><pre><code>	onStep: (x) ->
		<span class="keyword">unless</span> quiet
			console.log <span class="string">"<span class="subst">#{x}</span>"</span>.blue

</code></pre></td></tr><tr class="block"><td class="comment"><h2>onComplete</h2>

<p>Logs successful process completions in green</p>

<h3>Args:</h3>

<ul>
<li><em>x {String}</em>: message to log</li>
</ul></td><td class="code"><pre><code>	onComplete: (x) ->
		console.log <span class="string">"<span class="subst">#{x}</span>"</span>.green

</code></pre></td></tr><tr class="block"><td class="comment"><h2>onError</h2>

<p>Logs errors in red</p>

<h3>Args:</h3>

<ul>
<li><em>x {String}</em>: message to log</li>
</ul></td><td class="code"><pre><code>	onError: (x) ->
		console.log <span class="string">"!!! <span class="subst">#{x}</span> !!!"</span>.red

log = <span class="keyword">new</span> Log()

exports.log = log
_ = require <span class="string">"underscore"</span>
path = require <span class="string">"path"</span>
Commander = require( <span class="string">"Commander"</span> ).Command
</code></pre></td></tr><tr class="block"><td class="comment"><p>Configuration container</p></td><td class="code"><pre><code>config = { }
</code></pre></td></tr><tr class="block"><td class="comment"><p>Configuration defaults</p></td><td class="code"><pre><code>siteConfig =
	<span class="string">"source"</span>: <span class="string">"src"</span>
	<span class="string">"style"</span>: <span class="string">"style"</span>
	<span class="string">"markup"</span>: <span class="string">"markup"</span>
	<span class="string">"output"</span>: 
		{
			<span class="string">"source"</span>: [ <span class="string">"lib"</span>, <span class="string">"site/js"</span> ],
			<span class="string">"style"</span>: [ <span class="string">"css"</span>, <span class="string">"site/css"</span> ],
			<span class="string">"markup"</span>: <span class="string">"site/"</span>
		}
	<span class="string">"spec"</span>: <span class="string">"spec"</span>
	<span class="string">"ext"</span>: <span class="string">"ext"</span>
	<span class="string">"lint"</span>: {}
	<span class="string">"uglify"</span>: {}
	<span class="string">"cssmin"</span>: {}
	<span class="string">"hosts"</span>: {
	  <span class="string">"/"</span>: <span class="string">"site"</span>
	}

libConfig = 
	<span class="string">"source"</span>: <span class="string">"src"</span>
	<span class="string">"output"</span>: <span class="string">"lib"</span>
	<span class="string">"spec"</span>: <span class="string">"spec"</span>
	<span class="string">"ext"</span>: <span class="string">"ext"</span>
	<span class="string">"lint"</span>: {}
	<span class="string">"uglify"</span>: {}
	<span class="string">"hosts"</span>: {
	  <span class="string">"/"</span>: <span class="string">"spec"</span>
	}

defaultMocha =
	growl: <span class="literal">true</span>
	ignoreLeaks: <span class="literal">true</span>
	reporter: <span class="string">"spec"</span>
	ui: <span class="string">"bdd"</span>
	colors: <span class="literal">true</span>

defaultDoc =
	generator: <span class="string">"docco"</span>
	output: <span class="string">"docs"</span>

continuous = test = inProcess = quiet = debug = <span class="literal">false</span>

ext =
	gzip: <span class="string">"gz"</span>
	uglify: <span class="string">"min"</span>
	cssmin: <span class="string">"min"</span>

extensionLookup = 
	<span class="string">".css"</span>: <span class="string">"style"</span>
	<span class="string">".scss"</span>: <span class="string">"style"</span>
	<span class="string">".sass"</span>: <span class="string">"style"</span>
	<span class="string">".less"</span>: <span class="string">"style"</span>
	<span class="string">".stylus"</span>: <span class="string">"style"</span>
	<span class="string">".js"</span>: <span class="string">"source"</span>
	<span class="string">".coffee"</span>: <span class="string">"source"</span>
	<span class="string">".markdown"</span>: <span class="string">"markup"</span>
	<span class="string">".md"</span>: <span class="string">"markup"</span>
	<span class="string">".html"</span>: <span class="string">"markup"</span>
</code></pre></td></tr><tr class="block"><td class="comment"><h2>Configuration</h2>

<p>Do all the things!<br />Calling anvil from the command line runs this.</p></td><td class="code"><pre><code><span class="keyword">class</span> Configuration 

	constructor: ( @fp, @scheduler, @log ) ->
</code></pre></td></tr><tr class="block"><td class="comment"><h2>configure</h2>

<p>this call will return a configuration object that will<br />inform the rest of the process<br />* <em>onConfig {Function}</em>: the callback to invoke with a configuration object</p></td><td class="code"><pre><code>	configure: ( argList, onConfig ) ->
		self = <span class="keyword">this</span>
		command = <span class="keyword">new</span> Commander()
		command
			.version(<span class="string">"0.7.7"</span>)
			.option( <span class="string">"-b, --build [build file]"</span>, <span class="string">"Use a custom build file"</span>, <span class="string">"./build.json"</span> )
			.option( <span class="string">"--ci"</span>, <span class="string">"Run a continuous integration build"</span> )
			.option( <span class="string">"--host"</span>, <span class="string">"Setup a static HTTP host"</span> )
			.option( <span class="string">"--lib [project]"</span>, <span class="string">"Create a lib project at the folder [project]"</span> )
			.option( <span class="string">"--libfile [file name]"</span>, <span class="string">"Create a new lib build file named [file name]"</span> )
			.option( <span class="string">"--site [project]"</span>, <span class="string">"Create a site project at the folder [project]"</span> )
			.option( <span class="string">"--sitefile [file name]"</span>, <span class="string">"Create a new site build file named [file name]"</span> )
			.option( <span class="string">"--mocha"</span>, <span class="string">"Run specifications using Mocha"</span> )</code></pre></td></tr><tr class="block"><td class="comment"><p>.option( "--docco", "Create annotated source using docco" )</p></td><td class="code"><pre><code>			.option( <span class="string">"--ape"</span>, <span class="string">"Create annotated source using ape"</span> )
			.option( <span class="string">"-q, --quiet"</span>, <span class="string">"Only print completion and error messages"</span> )

		command.parse( argList );

		<span class="keyword">if</span> command.libfile <span class="keyword">or</span> command.sitefile</code></pre></td></tr><tr class="block"><td class="comment"><p>Generate all the directories and the config file</p></td><td class="code"><pre><code>			name = command.libfile <span class="keyword">or</span>= command.sitefile
			type = <span class="keyword">if</span> command.sitefile then <span class="string">'site'</span> <span class="keyword">else</span> <span class="string">'lib'</span>
			@writeConfig type, <span class="string">"<span class="subst">#{name}</span>.json"</span>, () ->
				self.log.onComplete <span class="string">"Created <span class="subst">#{ type }</span> build file - <span class="subst">#{ name }</span>"</span>
				onConfig config, <span class="literal">true</span>
		<span class="keyword">else</span> <span class="keyword">if</span> command.site <span class="keyword">or</span> command.lib</code></pre></td></tr><tr class="block"><td class="comment"><p>Generate all the directories and the config file</p></td><td class="code"><pre><code>			type = <span class="keyword">if</span> command.site then <span class="string">'site'</span> <span class="keyword">else</span> <span class="string">'lib'</span>
			scaffold = command.site <span class="keyword">or</span>= command.lib
			config = <span class="keyword">if</span> type == <span class="string">'site'</span> then siteConfig <span class="keyword">else</span> libConfig
			@log.onStep <span class="string">"Creating scaffolding for new <span class="subst">#{ type }</span> project"</span></code></pre></td></tr><tr class="block"><td class="comment"><p>Create all the directories</p></td><td class="code"><pre><code>			self.ensurePaths( () ->
				self.writeConfig( type, scaffold + <span class="string">"/build.json"</span>, () ->
					self.log.onComplete <span class="string">"Scaffold ( <span class="subst">#{ scaffold }</span> ) created."</span>
					onConfig config, <span class="literal">true</span>
				)
			, scaffold )
		<span class="keyword">else</span>
			buildFile = command.build
			@log.onStep <span class="string">"Checking for <span class="subst">#{ buildFile }</span>"</span>
			exists = @fp.pathExists buildFile
			@prepConfig exists, buildFile, () ->
				<span class="keyword">if</span> command.host
					config.host = <span class="literal">true</span>

				<span class="keyword">if</span> command.ci
					config.continuous = <span class="literal">true</span>

				<span class="keyword">if</span> command.mocha
					config.mocha = defaultMocha

				<span class="keyword">if</span> command.ape
					config.docs = defaultDoc
					config.docs.generator = <span class="string">"ape"</span>

				<span class="keyword">if</span> command.docco
					config.docs = defaultDoc
</code></pre></td></tr><tr class="block"><td class="comment"><p>Run transforms and generate output</p></td><td class="code"><pre><code>				self.ensurePaths () ->
					onConfig config		
</code></pre></td></tr><tr class="block"><td class="comment"><h2>createLibBuild</h2>

<p>This creates a file containing the default lib build convention</p></td><td class="code"><pre><code>	createLibBuild: () -></code></pre></td></tr><tr class="block"><td class="comment"><p>build lib template?</p></td><td class="code"><pre><code>		<span class="keyword">if</span> buildLibTemplate
			output = <span class="keyword">if</span> buildLibTemplate == <span class="literal">true</span> then <span class="string">"build.json"</span> <span class="keyword">else</span> buildLibTemplate
			writeConfig <span class="string">"lib"</span>, output
			global.process.exit(<span class="number">0</span>)
			config
</code></pre></td></tr><tr class="block"><td class="comment"><h2>createSiteBuild</h2>

<p>This creates a file containing the default site build convention</p></td><td class="code"><pre><code>	createSiteBuild: () -></code></pre></td></tr><tr class="block"><td class="comment"><p>build site template?</p></td><td class="code"><pre><code>		<span class="keyword">if</span> buildSiteTemplate
			output = <span class="keyword">if</span> buildSiteTemplate == <span class="literal">true</span> then <span class="string">"build.json"</span> <span class="keyword">else</span> buildSiteTemplate
			writeConfig <span class="string">"site"</span>, output
			global.process.exit(<span class="number">0</span>)
			config
</code></pre></td></tr><tr class="block"><td class="comment"><h2>ensurePaths</h2>

<p>Make sure that all expected paths exist</p>

<h3>Args:</h3>

<ul>
<li><em>onComplete {Function}</em>: what to call when work is complete</li>
<li><em>prefix {String}</em>: the prefix to prepend to all paths</li>
</ul></td><td class="code"><pre><code>	ensurePaths: ( onComplete, prefix ) ->
		self = <span class="keyword">this</span>
		prefix = prefix <span class="keyword">or</span>= <span class="string">""</span>
		config.working = config.working || <span class="string">"./tmp"</span>
		fp = @fp
		paths = [
			config[ <span class="string">"source"</span> ]
			config[ <span class="string">"style"</span> ]
			config[ <span class="string">"markup"</span> ]
			config[ <span class="string">"spec"</span> ]
			config[ <span class="string">"ext"</span> ]
			config[ <span class="string">"working"</span> ]
		]
</code></pre></td></tr><tr class="block"><td class="comment"><p>if documenting</p></td><td class="code"><pre><code>		<span class="keyword">if</span> config.docs
			paths.push config.docs.output
		
		outputList = []</code></pre></td></tr><tr class="block"><td class="comment"><p>if the output is an object</p></td><td class="code"><pre><code>		<span class="keyword">if</span> _.isObject config.output
			outputList = _.flatten config.output
		<span class="keyword">else</span></code></pre></td></tr><tr class="block"><td class="comment"><p>if output is a single path</p></td><td class="code"><pre><code>			outputList = [ config.output ]
		paths = paths.concat outputList
</code></pre></td></tr><tr class="block"><td class="comment"><p>if names</p></td><td class="code"><pre><code>		name = config.name
		<span class="keyword">if</span> name
			<span class="keyword">for</span> output <span class="keyword">in</span> outputList
				<span class="keyword">if</span> _.isString name
					nestedPath = path.dirname name
					<span class="keyword">if</span> nestedPath 
						paths.push path.join output, nestedPath
				<span class="keyword">else</span>
					nestedPaths = _.map _.flatten( name ), ( x ) -> path.join output, path.dirname( x )
					paths = paths.concat nestedPaths

		<span class="function"><span class="title">worker</span></span> = ( p, done ) -> 
			<span class="keyword">try</span> 
				fp.ensurePath [ prefix, p ], () ->
					done()
			<span class="keyword">catch</span> err
				done()

		@log.onStep <span class="string">"Ensuring project directory structure"</span>
		@scheduler.parallel paths, worker, onComplete
</code></pre></td></tr><tr class="block"><td class="comment"><h2>prepConfig</h2>

<p>Fallback to default config, if specified config doesn't exist</p>

<h3>Args:</h3>

<ul>
<li><em>exists {Boolean}</em>: does the specified config file exist?</li>
<li><em>file {String}</em>: config file name</li>
<li><em>onComplete {Function}</em>: what to do after config is prepped</li>
</ul></td><td class="code"><pre><code>	prepConfig: ( exists, file, onComplete ) ->
		self = <span class="keyword">this</span>
		onDone = () -> self.normalizeConfig onComplete		
		<span class="keyword">unless</span> exists
			@loadConvention( onDone )
		<span class="keyword">else</span>
			@loadConfig( file, onDone )
</code></pre></td></tr><tr class="block"><td class="comment"><h2>loadConfig</h2>

<p>Setup full configuration using specified config file <br />For example, anvil -b custom.json</p>

<h3>Args:</h3>

<ul>
<li><em>file {String}</em>: config file name</li>
<li><em>onComplete {Function}</em>: what to do after config is loaded</li>
</ul></td><td class="code"><pre><code>	loadConfig: ( file, onComplete ) ->
		@log.onStep <span class="string">"Loading config..."</span>
		fp = @fp
		fp.read file, ( content ) ->
			config = JSON.parse( content )
			<span class="keyword">if</span> config.extensions
				ext.gzip = config.extensions.gzip || ext.gzip
				ext.uglify = config.extensions.uglify || ext.uglify
</code></pre></td></tr><tr class="block"><td class="comment"><p>Carry on!</p></td><td class="code"><pre><code>			onComplete()
</code></pre></td></tr><tr class="block"><td class="comment"><h2>loadConvention</h2>

<p>Sets up default config if no config file is found</p>

<h3>Args:</h3>

<ul>
<li><em>onComplete {Function}</em>: what to do after config is setup</li>
</ul></td><td class="code"><pre><code>	loadConvention: ( onComplete ) ->
		isSite = @fp.pathExists <span class="string">"./site"</span>
		conventionConfig = <span class="keyword">if</span> isSite then siteConfig <span class="keyword">else</span> libConfig
		@log.onStep <span class="string">"No build file found, using <span class="subst">#{ <span class="keyword">if</span> isSite then 'site' <span class="keyword">else</span> 'lib' }</span> conventions"</span>
		config = conventionConfig
		onComplete()
</code></pre></td></tr><tr class="block"><td class="comment"><h2>normalizeConfig</h2>

<p>Tries to normalize differences in configuration formats<br />between options and site vs. lib configurations</p>

<h4>Args:</h4>

<ul>
<li><em>onComplete {Function}</em>: what to call when work is complete</li>
</ul></td><td class="code"><pre><code>	normalizeConfig: ( onComplete ) ->
		self = <span class="keyword">this</span>
		fp = @fp
		config.output = config.output || <span class="string">"lib"</span>
		<span class="keyword">if</span> _.isString config.output
			outputPath = config.output
			config.output =
				style: outputPath
				source: outputPath
				markup: outputPath

		calls = []
</code></pre></td></tr><tr class="block"><td class="comment"><p>finalization?</p></td><td class="code"><pre><code>		finalize = config.finalize
		<span class="keyword">if</span> finalize 
			calls.push ( done ) -> 
				self.getFinalization finalize, ( result ) -> 
					config.finalize = result
					done()</code></pre></td></tr><tr class="block"><td class="comment"><p>wrapping?</p></td><td class="code"><pre><code>		wrap = config.wrap
		<span class="keyword">if</span> wrap
			calls.push ( done ) -> 
				self.getWrap wrap, ( result ) -> 
					config.wrap = result
					done()

		<span class="keyword">if</span> config.mocha
			config.mocha = _.extend defaultMocha, config.mocha

		<span class="keyword">if</span> config.docs
			config.docs = _.extend defaultDoc, config.docs
</code></pre></td></tr><tr class="block"><td class="comment"><p>any calls?</p></td><td class="code"><pre><code>		<span class="keyword">if</span> calls.length > <span class="number">0</span>
			@scheduler.parallel calls, 
				( call, done ) -> 
					call( done )
				, () -> onComplete()
		<span class="keyword">else</span>
			onComplete()

</code></pre></td></tr><tr class="block"><td class="comment"><h2>getFinalization</h2>

<p>Build up a custom state machine to address how<br />finalization should happen for this project</p>

<h3>Args:</h3>

<ul>
<li><em>original {Object}</em>: the existing finalization block</li>
<li><em>onComplete {Function}</em>: what to call when work is complete</li>
</ul></td><td class="code"><pre><code>	getFinalization: ( original, onComplete ) ->
		self = <span class="keyword">this</span>
		finalization = {}
		result = {}
		aggregation = {}
		aggregate = @scheduler.aggregate
		</code></pre></td></tr><tr class="block"><td class="comment"><p>if there's no finalization</p></td><td class="code"><pre><code>		<span class="keyword">if</span> <span class="keyword">not</span> original <span class="keyword">or</span> _.isEqual original, {}
			onComplete finalization</code></pre></td></tr><tr class="block"><td class="comment"><p>if there's only one section</p></td><td class="code"><pre><code>		<span class="keyword">else</span> <span class="keyword">if</span> original.header <span class="keyword">or</span> 
				original[<span class="string">"header-file"</span>] <span class="keyword">or</span> 
				original.footer <span class="keyword">or</span> 
				original[<span class="string">"footer-file"</span>]</code></pre></td></tr><tr class="block"><td class="comment"><p>build out aggregation for resolving header and footer</p></td><td class="code"><pre><code>			@getContentBlock original, <span class="string">"header"</span>, aggregation
			@getContentBlock original, <span class="string">"footer"</span>, aggregation</code></pre></td></tr><tr class="block"><td class="comment"><p>make sure we don't try to aggregate on empty</p></td><td class="code"><pre><code>			<span class="keyword">if</span> _.isEqual aggregation, {}
				onComplete finalization
			<span class="keyword">else</span>
				aggregate aggregation, ( constructed ) ->
					finalization.source = constructed
					onComplete finalization</code></pre></td></tr><tr class="block"><td class="comment"><p>there are multiple sections</p></td><td class="code"><pre><code>		<span class="keyword">else</span>
			sources = {}
			blocks = { 
				<span class="string">"source"</span>: original[ <span class="string">"source"</span> ], 
				<span class="string">"style"</span>: original[ <span class="string">"style"</span> ], 
				<span class="string">"markup"</span>: original[ <span class="string">"markup"</span> ] 
			}
			_.each( blocks, ( block, name ) -> 
				subAggregate = {}
				self.getContentBlock block, <span class="string">"header"</span>, subAggregate
				self.getContentBlock block, <span class="string">"footer"</span>, subAggregate
				sources[ name ] = ( done ) -> 
					aggregate subAggregate, done
			)
			aggregate sources, onComplete
</code></pre></td></tr><tr class="block"><td class="comment"><h2>getWrap</h2>

<p>Build up a custom state machine to address how<br />wrapping should happen for this project</p>

<h3>Args:</h3>

<ul>
<li><em>original {Object}</em>: the existing wrap block</li>
<li><em>onComplete {Function}</em>: what to call when work is complete</li>
</ul></td><td class="code"><pre><code>	getWrap: ( original, onComplete ) ->
		self = <span class="keyword">this</span>
		wrap = {}
		result = {}
		aggregation = {}
		aggregate = @scheduler.aggregate</code></pre></td></tr><tr class="block"><td class="comment"><p>if there's no wrap</p></td><td class="code"><pre><code>		<span class="keyword">if</span> <span class="keyword">not</span> original <span class="keyword">or</span> _.isEqual original, {}
			onComplete wrap</code></pre></td></tr><tr class="block"><td class="comment"><p>if there's only one section</p></td><td class="code"><pre><code>		<span class="keyword">else</span> <span class="keyword">if</span> original.prefix <span class="keyword">or</span> 
				original[<span class="string">"prefix-file"</span>] <span class="keyword">or</span> 
				original.suffix <span class="keyword">or</span> 
				original[<span class="string">"suffix-file"</span>]</code></pre></td></tr><tr class="block"><td class="comment"><p>build out aggregation for resolving prefix and suffix</p></td><td class="code"><pre><code>			@getContentBlock original, <span class="string">"prefix"</span>, aggregation
			@getContentBlock original, <span class="string">"suffix"</span>, aggregation</code></pre></td></tr><tr class="block"><td class="comment"><p>make sure we don't try to aggregate on empty</p></td><td class="code"><pre><code>			<span class="keyword">if</span> _.isEqual aggregation, {}
				onComplete wrap
			<span class="keyword">else</span>
				aggregate aggregation, ( constructed ) ->
					wrap.source = constructed
					onComplete wrap</code></pre></td></tr><tr class="block"><td class="comment"><p>there are multiple sections</p></td><td class="code"><pre><code>		<span class="keyword">else</span>
			sources = {}
			blocks = { 
				<span class="string">"source"</span>: original[ <span class="string">"source"</span> ], 
				<span class="string">"style"</span>: original[ <span class="string">"style"</span> ], 
				<span class="string">"markup"</span>: original[ <span class="string">"markup"</span> ] 
			}
			_.each( blocks, ( block, name ) -> 
				subAggregate = {}
				self.getContentBlock block, <span class="string">"prefix"</span>, subAggregate
				self.getContentBlock block, <span class="string">"suffix"</span>, subAggregate
				sources[ name ] = ( done ) -> aggregate subAggregate, done
			)
			aggregate sources, onComplete
</code></pre></td></tr><tr class="block"><td class="comment"><h2>getContentBlock</h2>

<p>Normalizes a wrapper or finalizer segment</p>

<h3>Args:</h3>

<ul>
<li>_property {string}: the property name to check for</li>
<li><em>source {Object}</em>: the configuration block</li>
<li><em>onComplete {Function}</em>: what to call when work is complete</li>
</ul></td><td class="code"><pre><code>	getContentBlock: ( source, property, aggregation ) ->
		aggregation[ property ] = ( done ) -> done <span class="string">""</span>
		fp = @fp
		<span class="keyword">if</span> source
			propertyPath = source[<span class="string">"<span class="subst">#{ property }</span>-file"</span>]
			propertyValue = source[ property ]
			<span class="keyword">if</span> propertyPath <span class="keyword">and</span> @fp.pathExists propertyPath
				aggregation[ property ] = ( done ) -> 
					fp.read propertyPath, ( content ) ->
						done content
			<span class="keyword">else</span> <span class="keyword">if</span> propertyValue
				aggregation[ property ] = ( done ) -> done propertyValue
</code></pre></td></tr><tr class="block"><td class="comment"><h2>writeConfig</h2>

<p>Creates new default config file</p>

<h3>Args:</h3>

<ul>
<li><em>name {String}</em>: the config file name</li>
<li><em>onComplete {Function}</em>: what to call when work is complete</li>
</ul></td><td class="code"><pre><code>	writeConfig: ( type, name, onComplete ) ->
		config = <span class="keyword">if</span> type == <span class="string">"lib"</span> then libConfig <span class="keyword">else</span> siteConfig
		log = @log
		json = JSON.stringify( config, <span class="literal">null</span>, <span class="string">"\t"</span> )
		@fp.write name, json, () ->
			log.onComplete <span class="string">"<span class="subst">#{name}</span> created successfully!"</span>
			onComplete()

exports.configuration = Configuration

_ = require <span class="string">"underscore"</span></code></pre></td></tr><tr class="block"><td class="comment"><h2>Scheduler</h2>

<p>Provides flow control abstractions<br />aggregate and parallel are essentially fork/join variations and<br />pipeline is an asynchronous way to pass an input through a series<br />of transforms.</p></td><td class="code"><pre><code><span class="keyword">class</span> Scheduler

	constructor: () ->
</code></pre></td></tr><tr class="block"><td class="comment"><h2>parallel</h2>

<p>This takes a list of items and a single asynchronous<br />function with the signature ( item, done ) and<br />calls the worker for each item only invoking onComplete<br />once all calls have completed.<br />* <em>items {Array}</em>: a list of items to process<br />* <em>worker {Function}</em>: the worker that processes all the items<br />* <em>onComplete {Function}</em>: the function to call once all workers have completed</p></td><td class="code"><pre><code>	parallel: ( items, worker, onComplete ) -></code></pre></td></tr><tr class="block"><td class="comment"><p>Fail fast if list is empty</p></td><td class="code"><pre><code>		<span class="keyword">if</span> <span class="keyword">not</span> items <span class="keyword">or</span> items.length == <span class="number">0</span>
			onComplete []
		count = items.length
		results = []</code></pre></td></tr><tr class="block"><td class="comment"><p>Pushes <em>result</em> (if truthy) onto the <em>results</em> list and, if there are no more<br />items, calls <em>onComplete</em> with <em>results</em></p></td><td class="code"><pre><code>		<span class="function"><span class="title">done</span></span> = ( result ) ->
			count = count - <span class="number">1</span></code></pre></td></tr><tr class="block"><td class="comment"><p>Is <em>result</em> truthy?</p></td><td class="code"><pre><code>			<span class="keyword">if</span> result</code></pre></td></tr><tr class="block"><td class="comment"><p>Append to <em>results</em>!</p></td><td class="code"><pre><code>				results.push result</code></pre></td></tr><tr class="block"><td class="comment"><p>Is iteration complete?</p></td><td class="code"><pre><code>			<span class="keyword">if</span> count == <span class="number">0</span></code></pre></td></tr><tr class="block"><td class="comment"><p>Call <em>onComplete</em>!</p></td><td class="code"><pre><code>				onComplete( results )</code></pre></td></tr><tr class="block"><td class="comment"><p>Iteration occurs here</p></td><td class="code"><pre><code>		worker( item, done ) <span class="keyword">for</span> item <span class="keyword">in</span> items
</code></pre></td></tr><tr class="block"><td class="comment"><h2>pipeline</h2>

<p>This takes an item and mutates it by calling a series<br />of asynchronous workers with the signature ( item, done ) and<br />only invokes onComplete after the last function in the pipeline completes.<br />* <em>item {Object}</em>: the initial item to pass to the first call<br />* <em>workers {Array}</em>: the ordered list of functions that compose the pipeline<br />* <em>onComplete {Function}</em>: the function to call once the last function has completed</p></td><td class="code"><pre><code>	pipeline: ( item, workers, onComplete ) -></code></pre></td></tr><tr class="block"><td class="comment"><p>Fail fast if list is empty</p></td><td class="code"><pre><code>		<span class="keyword">if</span> item == <span class="literal">undefined</span> <span class="keyword">or</span> <span class="keyword">not</span> workers <span class="keyword">or</span> workers.length == <span class="number">0</span>
			onComplete item || {}
</code></pre></td></tr><tr class="block"><td class="comment"><p>take the next worker in the list<br />and pass item (in its current state) to it</p></td><td class="code"><pre><code>		<span class="function"><span class="title">iterate</span></span> = ( done ) ->
			worker = workers.shift()
			worker item, done
		<span class="function"><span class="title">done</span></span> = ->
		<span class="function"><span class="title">done</span></span> = ( product ) -></code></pre></td></tr><tr class="block"><td class="comment"><p>store the mutated product of the worker</p></td><td class="code"><pre><code>			item = product</code></pre></td></tr><tr class="block"><td class="comment"><p>Any workers remaining?</p></td><td class="code"><pre><code>			<span class="keyword">if</span> workers.length == <span class="number">0</span></code></pre></td></tr><tr class="block"><td class="comment"><p>Call <em>onComplete</em>!</p></td><td class="code"><pre><code>				onComplete( product )
			<span class="keyword">else</span>
				iterate done
</code></pre></td></tr><tr class="block"><td class="comment"><p>kick off the pipeline</p></td><td class="code"><pre><code>		iterate done
</code></pre></td></tr><tr class="block"><td class="comment"><h2>aggregate</h2>

<p>Takes a hash map of calls and returns a corresponding hash map of<br />the results once all calls have completed. It's a weird fork/join<br />with named results vs. a randomly ordered list of results<br />* <em>calls {Object}</em>: the hash map of named asynchronous functions to call<br />* <em>onComplete {Function}</em>: the resulting hash map of corresponding values</p></td><td class="code"><pre><code>	aggregate: ( calls, onComplete ) ->
		results = {}</code></pre></td></tr><tr class="block"><td class="comment"><p>checks to see if all results have been collected</p></td><td class="code"><pre><code>		isDone = () -> 
			_.chain( calls ).keys().all( ( x ) -> results[ x ] != <span class="literal">undefined</span> ).value()
		</code></pre></td></tr><tr class="block"><td class="comment"><p>build a callback for the specific named function</p></td><td class="code"><pre><code>		<span class="function"><span class="title">getCallback</span></span> = ( name ) ->
			( result ) ->
				results[ name ] = result</code></pre></td></tr><tr class="block"><td class="comment"><p>have all the other calls completed?</p></td><td class="code"><pre><code>				<span class="keyword">if</span> isDone()
					onComplete results
</code></pre></td></tr><tr class="block"><td class="comment"><p>iterate through the call list and invoke each one</p></td><td class="code"><pre><code>		_.each( calls, ( call, name ) ->
			callback = getCallback name
			call callback
		)

exports.scheduler = Scheduler

fs = require <span class="string">"fs"</span>
path = require <span class="string">"path"</span>
_ = require <span class="string">"underscore"</span>
</code></pre></td></tr><tr class="block"><td class="comment"><h2>FSCrawler</h2>

<p>Wrote a custom 'dive' replacement after<br />the API changed significantly. The needs of Anvil are<br />pretty unique - always crawl the whole directory structure<br />from the start point and don't start work until we know all the files.<br />This 'crawls' a directory and returns all the files in the<br />structure recursive.</p></td><td class="code"><pre><code><span class="keyword">class</span> FSCrawler

	constructor: ( @scheduler ) ->
		_.bindAll( <span class="keyword">this</span> )
</code></pre></td></tr><tr class="block"><td class="comment"><h2>crawl</h2>

<p>Crawls the whole directory structure starting with <em>directory</em><br />and returns the full file listing.<br />* <em>directory {String/Array}</em>: a string or path spec for the directory to start crawling at<br />* <em>onComplete {Function}</em>: the function to call with a complete list of all the files</p></td><td class="code"><pre><code>	crawl: ( directory, onComplete ) ->
		self = <span class="keyword">this</span>
		fileList = []
		forAll = @scheduler.parallel
		<span class="keyword">if</span> directory <span class="keyword">and</span> directory != <span class="string">""</span></code></pre></td></tr><tr class="block"><td class="comment"><p>get the fully qualified path</p></td><td class="code"><pre><code>			directory = path.resolve directory</code></pre></td></tr><tr class="block"><td class="comment"><p>read directory contents</p></td><td class="code"><pre><code>			fs.readdir directory, ( err, contents ) -></code></pre></td></tr><tr class="block"><td class="comment"><p>if we didn't get an error and we have contents</p></td><td class="code"><pre><code>				<span class="keyword">if</span> <span class="keyword">not</span> err <span class="keyword">and</span> contents.length > <span class="number">0</span>
					qualified = []</code></pre></td></tr><tr class="block"><td class="comment"><p>resolve and push qualified paths into the array</p></td><td class="code"><pre><code>					<span class="keyword">for</span> item <span class="keyword">in</span> contents
						qualified.push path.resolve directory, item
					</code></pre></td></tr><tr class="block"><td class="comment"><p>find out if we have a directory or a file handle for<br />all the results from fs.readdir</p></td><td class="code"><pre><code>					self.classifyHandles qualified, ( files, directories ) ->
						fileList = fileList.concat files</code></pre></td></tr><tr class="block"><td class="comment"><p>if we found any directories, continue crawling those</p></td><td class="code"><pre><code>						<span class="keyword">if</span> directories.length > <span class="number">0</span>
							forAll directories, self.crawl, ( files ) ->
								fileList = fileList.concat _.flatten files
								onComplete fileList</code></pre></td></tr><tr class="block"><td class="comment"><p>no more directories at this level, return the file list</p></td><td class="code"><pre><code>						<span class="keyword">else</span>
							onComplete fileList</code></pre></td></tr><tr class="block"><td class="comment"><p>there was a problem or no files, return the list, we're done here</p></td><td class="code"><pre><code>				<span class="keyword">else</span>
					onComplete fileList</code></pre></td></tr><tr class="block"><td class="comment"><p>no more to do, return the list</p></td><td class="code"><pre><code>		<span class="keyword">else</span>
			onComplete fileList
</code></pre></td></tr><tr class="block"><td class="comment"><h2>classifyHandles</h2>

<p>Provides a fork/join wrapper around getting the fs stat objects for the list<br />of paths.<br />* <em>list {Array}</em>: the list of paths to check<br />* <em>onComplete {Function}</em>: the function to call with the lists of files and directories</p></td><td class="code"><pre><code>	classifyHandles: ( list, onComplete ) ->
		<span class="keyword">if</span> list <span class="keyword">and</span> list.length > <span class="number">0</span>
			@scheduler.parallel list, @classifyHandle, ( classified ) ->
				files = []
				directories = []
				<span class="keyword">for</span> item <span class="keyword">in</span> classified
					<span class="keyword">if</span> item.isDirectory 
						directories.push item.file 
					<span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">not</span> item.error
						files.push item.file
				onComplete files, directories
		<span class="keyword">else</span>
			onComplete [], []
</code></pre></td></tr><tr class="block"><td class="comment"><h2>classifyHandle</h2>

<p>Get the fs stat and determine if the path is to a file or a directory<br />* <em>file {String}</em>: the path to check<br />* <em>onComplete {Function}</em>: the function to call with the result of the check</p></td><td class="code"><pre><code>	classifyHandle: ( file, onComplete ) ->	
		fs.stat file, ( err, stat ) ->
			<span class="keyword">if</span> err
				onComplete { file: file, err: err }
			<span class="keyword">else</span>
				onComplete { file: file, isDirectory: stat.isDirectory() }
		

exports.crawler = FSCrawler
fs = require <span class="string">"fs"</span>
_ = require <span class="string">"underscore"</span>
</code></pre></td></tr><tr class="block"><td class="comment"><h2>FSProvider</h2>

<p>An abstraction around file interaction.<br />This is necessary to test any of Anvil's file level<br />interactions.</p></td><td class="code"><pre><code><span class="keyword">class</span> FSProvider
	
	constructor: ( @crawler, @log ) ->
		_.bindAll <span class="keyword">this</span>
</code></pre></td></tr><tr class="block"><td class="comment"><h2>buildPath</h2>

<p>Given an array or string pathspec, return a string pathspec</p>

<h3>Args:</h3>

<ul>
<li><em>pathSpec {Array, String}</em>: pathspec of either an array of strings or a single string</li>
</ul></td><td class="code"><pre><code>	buildPath: ( pathSpec ) ->
		<span class="keyword">if</span> <span class="keyword">not</span> pathSpec 
			<span class="string">""</span>
		<span class="keyword">else</span>
			fullPath = pathSpec
			<span class="keyword">if</span> _.isArray( pathSpec )
				fullPath = path.join.apply {}, pathSpec
			fullPath
</code></pre></td></tr><tr class="block"><td class="comment"><h2>delete</h2>

<p>Deletes a file, given the file name (<em>file</em>) and its parent (<em>dir</em>)</p>

<h3>Args:</h3>

<ul>
<li><em>dir {String}</em>: pathspec of parent dir</li>
<li><em>filePath {String}</em>: file name or path spec array</li>
<li><em>onDeleted {Function}</em>: callback called if the file delete is successful</li>
</ul></td><td class="code"><pre><code>	<span class="keyword">delete</span>: ( filePath, onDeleted ) ->
		filePath = @buildPath filePath
		<span class="keyword">if</span> @pathExists filePath
			fs.unlink filePath, ( err ) ->
				onDeleted()
			
</code></pre></td></tr><tr class="block"><td class="comment"><h2>ensurePath</h2>

<p>Makes sure <em>pathSpec</em> path exists before calling <em>onComplete</em> by<br />calling <em>mkdir pathSpec...</em> if <em>pathSpec</em> does not initially exist</p>

<h3>Args:</h3>

<ul>
<li><em>pathSpec {String}</em>: path string or array</li>
<li><em>onComplete {Function}</em>: called if path exists or is successfully created</li>
</ul></td><td class="code"><pre><code>	ensurePath: ( pathSpec, onComplete ) ->
		pathSpec = @buildPath pathSpec
		path.exists pathSpec, ( exists ) ->
			<span class="keyword">unless</span> exists</code></pre></td></tr><tr class="block"><td class="comment"><p>No <em>target</em> yet. Let's make it!</p></td><td class="code"><pre><code>				mkdir pathSpec, <span class="string">"0755"</span>, ( err ) -></code></pre></td></tr><tr class="block"><td class="comment"><p>Couldn't make the path. Report and abort!</p></td><td class="code"><pre><code>					<span class="keyword">if</span> err
						log.onError <span class="string">"Could not create <span class="subst">#{pathSpec}</span>. <span class="subst">#{err}</span>"</span>
					<span class="keyword">else</span>
						onComplete()
			<span class="keyword">else</span>
				onComplete()
</code></pre></td></tr><tr class="block"><td class="comment"><h2>getFiles</h2>

<p>Get all files in a specific path specification<br />* <em>filePath {String/Array}</em>: a string or array specifying the path to get files for<br />* <em>onFiles {Function}</em>: the function to call with the list of full file paths</p></td><td class="code"><pre><code>	getFiles: ( filePath, onFiles ) ->
		<span class="keyword">if</span> <span class="keyword">not</span> filePath 
			onFiles []
		<span class="keyword">else</span>
			filePath = @buildPath filePath
			files = []
			@crawler.crawl filePath, onFiles
</code></pre></td></tr><tr class="block"><td class="comment"><h2>copy ##</h2>

<p>Copy a file<br />* <em>from {String/Array}</em>: the path spec for the file to copy<br />* <em>to {String/Array}</em>: the path spec for the destination<br />* <em>onComplete {Function}</em>: the function to call when the copy has completed</p></td><td class="code"><pre><code>	copy: ( from, to, onComplete ) ->
		from = <span class="keyword">this</span>.buildPath from
		to = <span class="keyword">this</span>.buildPath to
		console.log <span class="string">"Copying from <span class="subst">#{ from }</span> to <span class="subst">#{ to }</span>"</span>
		toDir = to.substring( <span class="number">0</span>, to.lastIndexOf( <span class="string">'/'</span> ) )
		console.log toDir, path.existsSync( toDir )
		fs.mkdirSync toDir <span class="keyword">unless</span> path.existsSync toDir
		readStream = <span class="literal">undefined</span>
		writeStream = fs.createWriteStream( to )
		( readStream = fs.createReadStream( from ) ).pipe( writeStream )
		readStream.<span class="literal">on</span> <span class="string">'end'</span>, () ->
			<span class="keyword">if</span> writeStream
				writeStream.destroySoon()
			onComplete()
</code></pre></td></tr><tr class="block"><td class="comment"><h2>pathExists</h2>

<p>Sychronously (GASP) check for the existence of a file or directory<br />* <em>pathSpec {String/Array}</em>: the string or path spec of the file or directory to check for</p></td><td class="code"><pre><code>	pathExists: ( pathSpec ) ->
		pathSpec = <span class="keyword">this</span>.buildPath pathSpec
		path.existsSync pathSpec
</code></pre></td></tr><tr class="block"><td class="comment"><h2>read</h2>

<p>Reads a file from <em>filePath</em> and calls <em>onFile</em> callback with contents (Asynchronously)</p>

<h3>Args:</h3>

<ul>
<li><em>filePath {String}</em>: pathspec of file to read and pass contents from</li>
<li><em>onContent {Function}</em>: callback to pass file's contents to</li>
</ul></td><td class="code"><pre><code>	read: ( filePath, onContent ) ->
		filePath = @buildPath filePath
		fs.readFile filePath, <span class="string">"utf8"</span>, ( err, content ) ->
			<span class="keyword">if</span> err
				log.onError <span class="string">"Could not read <span class="subst">#{ filePath }</span> : <span class="subst">#{ err }</span>"</span>
				onContent <span class="string">""</span>, err
			<span class="keyword">else</span>
				onContent content
</code></pre></td></tr><tr class="block"><td class="comment"><h2>readSync</h2>

<p>Reads a file from <em>filePath</em> ... synchronously ... SHAME! SHAAAAAAME! (ok, not really)<br />This function only exists for a specific use case in config, where there's literally<br />no advantage to reading files asynchronously but writing the code that way would<br />be a huge pain. Rationalization FTW</p>

<h3>Args:</h3>

<ul>
<li><em>filePath {String}</em>: pathspec of file to read and pass contents from</li>
</ul></td><td class="code"><pre><code>	readSync: ( filePath ) ->
		filePath = @buildPath filePath
		<span class="keyword">try</span>
			fs.readFileSync filePath, <span class="string">"utf8"</span>
		<span class="keyword">catch</span> err
			log.onError <span class="string">"Could not read <span class="subst">#{ filePath }</span> : <span class="subst">#{ err }</span>"</span>
			err
</code></pre></td></tr><tr class="block"><td class="comment"><h2>transformFile</h2>

<p>Given input file <em>filePath</em>, perform <em>transform</em> upon it then write the transformed content<br />to <em>outputPath</em> and call <em>onComplete</em>. (All operations performed asynchronously.)</p>

<h3>Args:</h3>

<ul>
<li><em>filePath {String}</em>: pathspec of file to transform</li>
<li><em>transform {Function}</em>: transform to perform on the file</li>
<li><em>outputPath {String}</em>: pathspec of output file</li>
<li><em>onComplete {Function}</em>: called when all operations are complete</li>
</ul></td><td class="code"><pre><code>	transform: ( filePath, transform, outputPath, onComplete ) ->
		self = <span class="keyword">this</span>
		filePath = @buildPath filePath
		outputPath = @buildPath outputPath
		<span class="keyword">this</span>.read(
			filePath,
			( content ) ->
				transform content, ( newContent, error ) ->
					<span class="keyword">if</span> <span class="keyword">not</span> error
						self.write outputPath, newContent, onComplete
					<span class="keyword">else</span>
						onComplete error
		)
</code></pre></td></tr><tr class="block"><td class="comment"><h2>write</h2>

<p>Writes <em>content</em> to file at <em>filePath</em> calling <em>done</em> after writing is complete (Asynchronously)</p>

<h3>Args:</h3>

<ul>
<li><em>filePath {String}</em>: pathspec of file to write</li>
<li><em>content {String}</em>: content to write to the file</li>
<li><em>onComplete {Function}</em>: called when all operations are complete</li>
</ul></td><td class="code"><pre><code>	write: ( filePath, content, onComplete ) ->
		filePath = @buildPath filePath
		fs.writeFile filePath, content, <span class="string">"utf8"</span>, ( err ) ->
			<span class="keyword">if</span> err
				log.onError <span class="string">"Could not write <span class="subst">#{ filePath }</span> : <span class="subst">#{ err }</span>"</span>
				onComplete err
			<span class="keyword">else</span>
				onComplete()

exports.fsProvider = FSProvider

</code></pre></td></tr><tr class="block"><td class="comment"><p>Unfancy JavaScript -- <br />See <a href='http://coffeescript.org/'>http://coffeescript.org/</a> for more info</p></td><td class="code"><pre><code>coffeeScript = require <span class="string">"coffee-script"</span>
</code></pre></td></tr><tr class="block"><td class="comment"><p>LESS Compiler --<br />See <a href='http://lesscss.org'>http://lesscss.org</a></p></td><td class="code"><pre><code>less = require( <span class="string">"less"</span> )
</code></pre></td></tr><tr class="block"><td class="comment"><p>STYLUS Compiler --<br />See <a href='http://learnboost.github.com/stylus/'>http://learnboost.github.com/stylus/</a></p></td><td class="code"><pre><code>stylus = require( <span class="string">"stylus"</span> )
</code></pre></td></tr><tr class="block"><td class="comment"><p>HAML Compiler --<br />See <a href='http://haml-lang.com/'>http://haml-lang.com/</a></p></td><td class="code"><pre><code>haml = require( <span class="string">"haml"</span> )
</code></pre></td></tr><tr class="block"><td class="comment"><p>Markdown Compiler --<br />See <a href='https://github.com/chjj/marked'>http://github.com/chjj/marked</a></p></td><td class="code"><pre><code>marked = require( <span class="string">"marked"</span> )
marked.setOptions { sanitize: <span class="literal">false</span> }
</code></pre></td></tr><tr class="block"><td class="comment"><p>HAML Compiler --<br />See <a href='http://haml-lang.com/'>http://haml-lang.com/</a></p></td><td class="code"><pre><code>coffeeKup = require( <span class="string">"coffeekup"</span> )
</code></pre></td></tr><tr class="block"><td class="comment"><p>underscore --<br />The most essential JS lib that ever was<br />See <a href='http://underscorejs.org/'>http://underscorejs.org/</a></p></td><td class="code"><pre><code>_ = require <span class="string">"underscore"</span>
</code></pre></td></tr><tr class="block"><td class="comment"><h2>Compiler</h2>

<p>'Compiles' files based on the extension to produce<br />browser friendly resources: JS, CSS, HTML</p></td><td class="code"><pre><code><span class="keyword">class</span> Compiler

	constructor: (@fp, @log) ->
		_.bindAll( <span class="keyword">this</span> )
</code></pre></td></tr><tr class="block"><td class="comment"><h2>compile</h2>

<p>Compiles a file with the correct compiler</p>

<h3>Args:</h3>

<ul>
<li><em>file {Object}</em>: file metadata for the file to compile</li>
<li><em>onComplete {Function}</em>: function to invoke when done</li>
</ul></td><td class="code"><pre><code>	compile: ( file, onComplete ) ->
		self = <span class="keyword">this</span>
		ext = file.ext()
		newExt = @extensionMap[ ext ]
		newFile = file.name.replace ext, newExt
		log = @log
		log.onEvent <span class="string">"Compiling <span class="subst">#{ file.name }</span> to <span class="subst">#{ newFile }</span>"</span>
		compiler = @compilers[ ext ]
		<span class="keyword">if</span> compiler
			@fp.transform( 
				[ file.workingPath, file.name ],
				compiler,
				[ file.workingPath, newFile ],
				( err ) ->
					<span class="keyword">unless</span> err
						file.name = newFile
						onComplete file
					<span class="keyword">else</span>
						log.onError <span class="string">"Error compiling <span class="subst">#{ file.name }</span>: \r\n <span class="subst">#{ err }</span>"</span>
						onComplete err
			)
		<span class="keyword">else</span>
			onComplete file
</code></pre></td></tr><tr class="block"><td class="comment"><h2>extensionMap</h2>

<p>Provides a map of original to resulting extension</p></td><td class="code"><pre><code>	extensionMap:
		<span class="string">".js"</span>: <span class="string">".js"</span>
		<span class="string">".css"</span>: <span class="string">".css"</span>
		<span class="string">".html"</span>: <span class="string">".html"</span>
		<span class="string">".coffee"</span> : <span class="string">".js"</span>
		<span class="string">".kup"</span>: <span class="string">".html"</span>
		<span class="string">".less"</span>: <span class="string">".css"</span>
		<span class="string">".styl"</span>: <span class="string">".css"</span>
		<span class="string">".sass"</span>: <span class="string">".css"</span>
		<span class="string">".scss"</span>: <span class="string">".css"</span>
		<span class="string">".haml"</span>: <span class="string">".html"</span>
		<span class="string">".md"</span>: <span class="string">".html"</span>
		<span class="string">".markdown"</span>: <span class="string">".html"</span>
</code></pre></td></tr><tr class="block"><td class="comment"><h2>compilers</h2>

<p>A simple hash map of file extension to a function that<br />invokes the corresponding compiler</p></td><td class="code"><pre><code>	compilers:
		<span class="string">".coffee"</span> : ( content, onContent ) ->
			<span class="keyword">try</span>
				js = coffeeScript.compile content, { bare: <span class="literal">true</span> }
				onContent js
			<span class="keyword">catch</span> error
				onContent <span class="string">""</span>, error
		<span class="string">".less"</span> : ( content, onContent ) ->
			<span class="keyword">try</span>
				less.render( content, {}, (e, css) -> onContent(css) )
			<span class="keyword">catch</span> error
				onContent <span class="string">""</span>, error
		<span class="string">".sass"</span> : ( content, onContent ) ->
			<span class="keyword">try</span>
				onContent content
			<span class="keyword">catch</span> error
				onContent <span class="string">""</span>, error
		<span class="string">".scss"</span> : ( content, onContent ) ->
			<span class="keyword">try</span>
				onContent content
			<span class="keyword">catch</span> error
				onContent <span class="string">""</span>, error
		<span class="string">".styl"</span> : ( content, onContent ) ->
			<span class="keyword">try</span>
				stylus.render( content, {}, (e, css) -> onContent( css, e ) )
			<span class="keyword">catch</span> error
				onContent <span class="string">""</span>, error
		<span class="string">".haml"</span> : ( content, onContent ) ->
			<span class="keyword">try</span>
				html = haml.render content
				onContent html
			<span class="keyword">catch</span> error
				onContent <span class="string">""</span>, error
		<span class="string">".md"</span> : ( content, onContent ) ->
			<span class="keyword">try</span>
				onContent( marked.parse( content ) )
			<span class="keyword">catch</span> error
				onContent <span class="string">""</span>, error
		<span class="string">".markdown"</span> : ( content, onContent ) ->
			<span class="keyword">try</span>
				onContent( marked.parse( content ) )
			<span class="keyword">catch</span> error
				onContent <span class="string">""</span>, error
		<span class="string">".kup"</span> : ( content, onContent ) ->
			<span class="keyword">try</span>
				html =( coffeeKup.compile content, {} )()
				onContent html
			<span class="keyword">catch</span> error
				onContent <span class="string">""</span>, error

exports.compiler = Compiler

_ = require <span class="string">"underscore"</span>
</code></pre></td></tr><tr class="block"><td class="comment"><h2>Combiner</h2>

<p>Combines imports with the files importing them</p></td><td class="code"><pre><code><span class="keyword">class</span> Combiner

	constructor: ( @fp, @scheduler, @findPatterns, @replacePatterns ) ->
</code></pre></td></tr><tr class="block"><td class="comment"><h2>combineList</h2>

<p>combine all the files in the <em>list</em> and call onComplete when finished</p>

<h3>Args:</h3>

<ul>
<li><em>list {Array}</em>: collection of file metadata</li>
<li><em>onComplete {Function}</em>: callback to invoke on completion</li>
</ul></td><td class="code"><pre><code>	combineList: ( list, onComplete ) ->
		self = <span class="keyword">this</span>
		forAll = @scheduler.parallel</code></pre></td></tr><tr class="block"><td class="comment"><p>for all files in the list<br />    find all the imports for every file<br />then find all the files that depend on each file<br />then combine all the files in the list</p></td><td class="code"><pre><code>		findImports = _.bind( ( file, done ) ->
				self.findImports file, list, done
			, <span class="keyword">this</span> )
</code></pre></td></tr><tr class="block"><td class="comment"><p>once the imports are known, we can determine how many<br />files import (or depend) a given file</p></td><td class="code"><pre><code>		findDependents = _.bind( ( file, done ) ->
				self.findDependents file, list, done
			, <span class="keyword">this</span> )
</code></pre></td></tr><tr class="block"><td class="comment"><p>replace all of file's import statements with<br />the imported files' contents</p></td><td class="code"><pre><code>		combineFile = _.bind( ( file, done ) ->
			self.combineFile file, done
			, <span class="keyword">this</span> )
</code></pre></td></tr><tr class="block"><td class="comment"><p>combine all the files</p></td><td class="code"><pre><code>		forAll list, findImports, () ->
			<span class="keyword">for</span> f1 <span class="keyword">in</span> list
				findDependents f1, list
			forAll list, combineFile, onComplete
</code></pre></td></tr><tr class="block"><td class="comment"><h2>combineFile</h2>

<p>combine a specifc <em>file</em> after ensuring it's dependencies have been combined</p>

<h3>Args:</h3>

<ul>
<li><em>file {Object}</em>: the file metadata describing the file to combine</li>
<li><em>onComplete {Function}</em>: callback to invoke on completion</li>
</ul></td><td class="code"><pre><code>	combineFile: ( file, onComplete ) ->
		self = <span class="keyword">this</span>
		forAll = @scheduler.parallel</code></pre></td></tr><tr class="block"><td class="comment"><p>if we've already combined this file, just call complete</p></td><td class="code"><pre><code>		<span class="keyword">if</span> file.combined
			onComplete()</code></pre></td></tr><tr class="block"><td class="comment"><p>otherwise, combine all the file's dependencies first, then combine the file</p></td><td class="code"><pre><code>		<span class="keyword">else</span>
			<span class="function"><span class="title">combineFile</span></span> = ( file, done ) ->
				self.combineFile file, done

			dependencies = file.imports
			<span class="keyword">if</span> dependencies <span class="keyword">and</span> dependencies.length > <span class="number">0</span>
				forAll dependencies, combineFile, () ->
					self.combine file, () ->
						file.combined = <span class="literal">true</span>
						onComplete()
			<span class="keyword">else</span>
				self.combine file, () ->
					file.combined = <span class="literal">true</span>
					onComplete()
</code></pre></td></tr><tr class="block"><td class="comment"><h2>fileImports</h2>

<p>search the <em>file</em> using regex patterns and store all referenced files</p>

<h3>Args:</h3>

<ul>
<li><em>file {Object}</em>: the file metadata describing the file to combine</li>
<li><em>list {Array}</em>: collection of file metadata</li>
<li><em>onComplete {Function}</em>: callback to invoke on completion</li>
</ul></td><td class="code"><pre><code>	findImports: ( file, list, onComplete ) ->
		self = <span class="keyword">this</span>
		src = config.source <span class="keyword">or</span> <span class="string">'src'</span>
		imports = []
		console.log <span class="string">"About to read from <span class="subst">#{file.workingPath}</span>/<span class="subst">#{file.name}</span>"</span>
		@fp.read [ file.workingPath, file.name ], ( content ) ->
			console.log <span class="string">"Read from <span class="subst">#{file.workingPath}</span>/<span class="subst">#{file.name}</span>"</span></code></pre></td></tr><tr class="block"><td class="comment"><p>find the import statements in the file contents using @findPatterns</p></td><td class="code"><pre><code>			<span class="keyword">for</span> pattern <span class="keyword">in</span> self.findPatterns
				imports = imports.concat content.match pattern
			imports = _.filter imports, ( x ) -> x</code></pre></td></tr><tr class="block"><td class="comment"><p>strip out all the raw file names from the import statements<br />find the matching file metadata for the import</p></td><td class="code"><pre><code>			<span class="keyword">for</span> imported <span class="keyword">in</span> imports
				importName = ( imported.match <span class="regexp">///['\"].*['\"]///</span> )[ <span class="number">0</span> ].replace(<span class="regexp">///['\"]///</span>g, <span class="string">""</span> )
				importPath = <span class="string">"<span class="subst">#{ process.cwd() }</span>/<span class="subst">#{ src }</span>/<span class="subst">#{ importName }</span>"</span>.replace( /\/+/g, <span class="string">'/'</span> )
				importedFile = _.find( list, ( i ) -> 
					i.fullPath == importPath )
				console.log <span class="string">"importName: <span class="subst">#{ importName }</span>"</span>
				importedFile.name = importName
				console.log <span class="string">"<span class="subst">#{ importName }</span> --- <span class="subst">#{ importedFile.name }</span>"</span>
				file.imports.push importedFile
			onComplete()
</code></pre></td></tr><tr class="block"><td class="comment"><h2>fileDependents</h2>

<p>search the <em>list</em> to see if any files import <em>file</em></p>

<h3>Args:</h3>

<ul>
<li><em>file {Object}</em>: the file metadata describing the file to combine</li>
<li><em>list {Array}</em>: collection of file metadata</li>
<li><em>onComplete {Function}</em>: callback to invoke on completion</li>
</ul></td><td class="code"><pre><code>	findDependents: ( file, list ) ->
		<span class="function"><span class="title">imported</span></span> = ( importFile ) ->
			file.fullPath == importFile.fullPath
		<span class="keyword">for</span> item <span class="keyword">in</span> list
			<span class="keyword">if</span> _.any item.imports, imported then file.dependents++
</code></pre></td></tr><tr class="block"><td class="comment"><h2>combine</h2>

<p>combine all the <em>file</em>'s imports into its contents</p>

<h3>Args:</h3>

<ul>
<li><em>file {Object}</em>: the file metadata describing the file to combine</li>
<li><em>onComplete {Function}</em>: callback to invoke on completion</li>
</ul></td><td class="code"><pre><code>	combine: ( file, onComplete ) ->
		self = <span class="keyword">this</span>
		<span class="keyword">unless</span> file.combined
			pipe = @scheduler.pipeline
			fp = @fp
			<span class="keyword">if</span> file.imports.length > <span class="number">0</span></code></pre></td></tr><tr class="block"><td class="comment"><p>creates a closure around a specific import to prevent<br />access to a changing variable</p></td><td class="code"><pre><code>				steps = <span class="keyword">for</span> imported <span class="keyword">in</span> file.imports
						self.getStep imported
				fp.read [ file.workingPath, file.name ], ( main ) ->
					pipe main, steps, ( result ) ->
						fp.write [ file.workingPath, file.name ], result, () -> onComplete()
			<span class="keyword">else</span>
				onComplete()
		<span class="keyword">else</span>
			onComplete()
</code></pre></td></tr><tr class="block"><td class="comment"><h2>getStep</h2>

<p>This is insane but it works - creating a closure around<br />a specific import to prevent accessing a changing variable.<br />* <em>import {String}</em>: the imported file to create the closure around</p></td><td class="code"><pre><code>	getStep: ( imported ) -> 
		self = <span class="keyword">this</span>
		( text, onDone ) -> self.replace text, imported, onDone
</code></pre></td></tr><tr class="block"><td class="comment"><h2>replace</h2>

<p>create a replacement regex that will take the <em>imported</em> content and replace the<br />matched patterns within the main file's <em>content</em></p>

<h3>Args:</h3>

<ul>
<li><em>content {Object}</em>: the content of the main file</li>
<li><em>imported {Object}</em>: file metadata for the imported</li>
<li><em>onComplete {Function}</em>: callback to invoke on completion</li>
</ul></td><td class="code"><pre><code>	replace: ( content, imported, onComplete ) ->
		patterns = @replacePatterns
		pipe = @scheduler.pipeline
		source = imported.name
		working = imported.workingPath
		@fp.read [ working, source ], ( newContent ) ->
			steps = <span class="keyword">for</span> pattern <span class="keyword">in</span> patterns</code></pre></td></tr><tr class="block"><td class="comment"><p>creates a function that will replace the import statement<br />with a specific file's contents</p></td><td class="code"><pre><code>				( current, done ) ->
					stringified = pattern.toString().replace <span class="regexp">///replace///</span>, source
					stringified = stringified.substring( <span class="number">1</span>, stringified.length - <span class="number">2</span> )
					fullPattern = <span class="keyword">new</span> RegExp stringified, <span class="string">"g"</span>					
					capture = fullPattern.exec( content )
					<span class="keyword">if</span> capture <span class="keyword">and</span> capture.length > <span class="number">1</span></code></pre></td></tr><tr class="block"><td class="comment"><p>capture the indentation of the import</p></td><td class="code"><pre><code>						whiteSpace = capture[<span class="number">1</span>]</code></pre></td></tr><tr class="block"><td class="comment"><p>apply indentation to all lines of the new content</p></td><td class="code"><pre><code>						newContent = <span class="string">"<span class="subst">#{ whiteSpace }</span>"</span> + newContent.replace <span class="regexp">///\n///</span>g, <span class="string">"\n<span class="subst">#{ whiteSpace }</span>"</span>
					sanitized = current.replace( fullPattern, newContent.replace( <span class="string">"\$"</span>, <span class="string">"$"</span> ) ).replace( <span class="string">"$"</span>, <span class="string">"$"</span> )
					done sanitized
			pipe content, steps, ( result ) ->
				onComplete result

exports.combiner = Combiner</code></pre></td></tr><tr class="block"><td class="comment"><p>Uglify: JavaScript parser and compressor/beautifier toolkit -- <br />See <a href='https://github.com/mishoo/UglifyJS'>https://github.com/mishoo/UglifyJS</a> for more info</p></td><td class="code"><pre><code>jsp = require( <span class="string">"uglify-js"</span> ).parser
pro = require( <span class="string">"uglify-js"</span> ).uglify
</code></pre></td></tr><tr class="block"><td class="comment"><p>A Node-compatible port of Douglas Crockford's JSLint -- </p></td><td class="code"><pre><code>jslint = require( <span class="string">"readyjslint"</span> ).JSLINT
</code></pre></td></tr><tr class="block"><td class="comment"><p>CSS Minifier --<br />See <a href='https://github.com/jbleuzen/node-cssmin'>https://github.com/jbleuzen/node-cssmin</a></p></td><td class="code"><pre><code>cssminifier = require <span class="string">"cssmin"</span>

</code></pre></td></tr><tr class="block"><td class="comment"><h2>StylePipeline</h2>

<p>The set of post-processes that happen to completed style outputs.<br />These include minification, wrapping and<br />finalization depending on the build configuration.</p></td><td class="code"><pre><code><span class="keyword">class</span> StylePipeline

	constructor: ( @config, @fp, @minifier, @scheduler, @log ) ->
		_.bindAll( <span class="keyword">this</span> )
</code></pre></td></tr><tr class="block"><td class="comment"><h2>process</h2>

<p>Take the list of files and minify, wrap and finalize them<br />according to configuration. In the event that files are minified,<br />this function will create a seperate set of files to separate<br />processing between developer friendly and deployment friendly files.<br />* <em>files {Array}</em>: the list of files to process<br />* <em>onComplete {Array}</em>: the function to call with the list of files</p></td><td class="code"><pre><code>	process: ( files, onComplete ) ->
		self = <span class="keyword">this</span>
		forAll = @scheduler.parallel
		forAll files, @wrap, () ->
			minified = []
			<span class="keyword">if</span> self.config.cssmin
				minified = _.map( files, ( x ) -> _.clone x )
			forAll files, self.finalize, () -> 
				self.log.onStep <span class="string">"Finalizing CSS"</span>
				forAll minified, self.minify, () -> 
					<span class="keyword">if</span> minified.length > <span class="number">0</span>
						self.log.onStep <span class="string">"Minifying CSS"</span>
					forAll minified, self.finalize, () -> 
						onComplete( files.concat minified )
</code></pre></td></tr><tr class="block"><td class="comment"><h2>minify</h2>

<p>Uses the cssmin lib to minify the output styles<br />* <em>file {String}</em>: the file to minify<br />* <em>onComplete {Function}</em>: the function to call after minification has completed</p></td><td class="code"><pre><code>	minify: ( file, onComplete ) ->
		<span class="keyword">if</span> @config.cssmin
			@log.onEvent <span class="string">"Minifying <span class="subst">#{ file.name }</span>"</span>
			self = <span class="keyword">this</span>
			ext = file.ext()
			newFile = file.name.replace ext, <span class="string">".min.css"</span>
			self.fp.transform( 
				[ file.workingPath, file.name ],
				( content, onTransform ) ->
					onTransform( self.minifier.cssmin content )
				, [ file.workingPath, newFile ],
				( ) ->
					file.name = newFile
					onComplete()
			)
		<span class="keyword">else</span>
			onComplete()
</code></pre></td></tr><tr class="block"><td class="comment"><h2>finalize</h2>

<p>Finalize, for lack of a better term, puts header and footer content around the file's contents.<br />This step is different than wrapping because it happens AFTER minification and won't get<br />mangled as a result.<br />* <em>file {String}</em>: the file to finalize<br />* <em>onComplete {Function}</em>: the function to call after finalization has completed</p></td><td class="code"><pre><code>	finalize: ( file, onComplete ) ->
		self = <span class="keyword">this</span>
		<span class="keyword">if</span> @config.finalize <span class="keyword">and</span> @config.finalize.style
			@log.onEvent <span class="string">"Finalizing <span class="subst">#{ file.name }</span>"</span>
			header = @config.finalize.style.header
			footer = @config.finalize.style.footer
			@fp.transform( 
				[ file.workingPath, file.name ], 
				( content, onTransform ) ->
					<span class="keyword">if</span> header
						content = header + content
					<span class="keyword">if</span> footer
						content = content + footer
					onTransform content
				, [ file.workingPath, file.name ],
				onComplete
			)
		<span class="keyword">else</span>
			onComplete()
</code></pre></td></tr><tr class="block"><td class="comment"><h2>finalize</h2>

<p>Wraps the contents of the file with a prefix and suffix before minification occurs.<br />* <em>file {String}</em>: the file to wrap<br />* <em>onComplete {Function}</em>: the function to call after wrapping has completed</p></td><td class="code"><pre><code>	wrap: ( file, onComplete ) ->
		self = <span class="keyword">this</span>
		<span class="keyword">if</span> @config.wrap <span class="keyword">and</span> @config.wrap.style
			@log.onEvent <span class="string">"Wrapping <span class="subst">#{ file.name }</span>"</span>
			prefix = @config.wrap.style.prefix
			suffix = @config.wrap.style.suffix
			@fp.transform( 
				[ file.workingPath, file.name ], 
				( content, onTransform ) ->
					<span class="keyword">if</span> prefix
						content = prefix + content
					<span class="keyword">if</span> suffix
						content = content + suffix
					onTransform content
				, [ file.workingPath, file.name ],
				onComplete
			)
		<span class="keyword">else</span>
			onComplete()
</code></pre></td></tr><tr class="block"><td class="comment"><h2>StylePipeline</h2>

<p>The set of post-processes that happen to completed style outputs. <br />These include minification, wrapping and<br />finalization depending on the build configuration.</p></td><td class="code"><pre><code><span class="keyword">class</span> SourcePipeline

	constructor: ( @config, @fp, @minifier, @scheduler, @log ) ->
		_.bindAll( <span class="keyword">this</span> )
</code></pre></td></tr><tr class="block"><td class="comment"><h2>process</h2>

<p>Take the list of files and minify, wrap and finalize them<br />according to configuration. In the event that files are minified,<br />this function will create a seperate set of files to separate<br />processing between developer friendly and deployment friendly files.<br />* <em>files {Array}</em>: the list of files to process<br />* <em>onComplete {Array}</em>: the function to call with the list of files</p></td><td class="code"><pre><code>	process: ( files, onComplete ) ->
		self = <span class="keyword">this</span>
		forAll = @scheduler.parallel
		forAll files, @wrap, () ->
			minify = []
			<span class="keyword">if</span> self.config.uglify
				minify = _.map( files, ( x ) -> _.clone x )
			forAll files, self.finalize, () -> 
				self.log.onStep <span class="string">"Finalizing source files"</span>
				forAll minify, self.minify, () -> 
					<span class="keyword">if</span> minify.length > <span class="number">0</span>
						self.log.onStep <span class="string">"Minifying source files"</span>
					forAll minify, self.finalize, () -> 
						onComplete( files.concat minify )
</code></pre></td></tr><tr class="block"><td class="comment"><h2>minify</h2>

<p>Uses the uglify lib to minify the output source<br />* <em>file {String}</em>: the file to minify<br />* <em>onComplete {Function}</em>: the function to call after minification has completed</p></td><td class="code"><pre><code>	minify: ( file, onComplete ) ->
		exclusions = @config.uglify?.exclude || []
		isExcluded = _.any exclusions, ( x ) -> x == file.name
		<span class="keyword">if</span> @config.uglify <span class="keyword">and</span> <span class="keyword">not</span> isExcluded
			self = <span class="keyword">this</span>
			ext = file.ext()
			newFile = file.name.replace ext, <span class="string">".min.js"</span>
			@log.onEvent <span class="string">"Minifying <span class="subst">#{ newFile }</span>"</span>
			@fp.transform( 
				[ file.workingPath, file.name ],
				( content, onTransform ) ->
					self.minifier content, ( err, result ) ->
						<span class="keyword">if</span> err
							self.log.onError <span class="string">"Error minifying <span class="subst">#{ file.name }</span> : \r\n\t <span class="subst">#{ err }</span>"</span>
							result = content
						onTransform( result )
				, [ file.workingPath, newFile ],
				() ->
					file.name = newFile
					onComplete()
			)
		<span class="keyword">else</span>
			onComplete()
</code></pre></td></tr><tr class="block"><td class="comment"><h2>finalize</h2>

<p>Finalize, for lack of a better term, puts header and footer content around the file's contents.<br />This step is different than wrapping because it happens AFTER minification and won't get<br />mangled as a result.<br />* <em>file {String}</em>: the file to finalize<br />* <em>onComplete {Function}</em>: the function to call after finalization has completed</p></td><td class="code"><pre><code>	finalize: ( file, onComplete ) ->
		self = <span class="keyword">this</span>
		<span class="keyword">if</span> @config.finalize <span class="keyword">and</span> @config.finalize.source
			@log.onEvent <span class="string">"Finalizing <span class="subst">#{ file.name }</span>"</span>
			header = @config.finalize.source.header
			footer = @config.finalize.source.footer
			@fp.transform( 
				[ file.workingPath, file.name ], 
				( content, onTransform ) ->
					<span class="keyword">if</span> header
						content = header + content
					<span class="keyword">if</span> footer
						content = content + footer
					onTransform content
				, [ file.workingPath, file.name ],
				() ->
					onComplete()
			)
		<span class="keyword">else</span>
			onComplete()
</code></pre></td></tr><tr class="block"><td class="comment"><h2>finalize</h2>

<p>Wraps the contents of the file with a prefix and suffix before minification occurs.<br />* <em>file {String}</em>: the file to wrap<br />* <em>onComplete {Function}</em>: the function to call after wrapping has completed</p></td><td class="code"><pre><code>	wrap: ( file, onComplete ) ->
		self = <span class="keyword">this</span>
		<span class="keyword">if</span> @config.wrap <span class="keyword">and</span> @config.wrap.source
			@log.onEvent <span class="string">"Wrapping <span class="subst">#{ file.name }</span>"</span>
			prefix = @config.wrap.source.prefix
			suffix = @config.wrap.source.suffix  
			@fp.transform( 
				[ file.workingPath, file.name ], 
				( content, onTransform ) ->
					<span class="keyword">if</span> prefix
						content = prefix + content
					<span class="keyword">if</span> suffix
						content = content + suffix
					onTransform content
				, [ file.workingPath, file.name ],
				() ->
					onComplete()
			)
		<span class="keyword">else</span>
			onComplete()
</code></pre></td></tr><tr class="block"><td class="comment"><h2>MarkupPipeline</h2>

<p>Provides is a placeholder as there are currently<br />no post-process steps for markup.</p></td><td class="code"><pre><code><span class="keyword">class</span> MarkupPipeline

	constructor: () ->
</code></pre></td></tr><tr class="block"><td class="comment"><h2>PostProcessor</h2>

<p>A provider abstraction around post-process steps for each resource<br />type that allows Anvil to have a 'branchless' pipeline for all <br />resource types</p></td><td class="code"><pre><code><span class="keyword">class</span> PostProcessor

	constructor: ( @config, @fp, @scheduler, @log ) ->

		<span class="function"><span class="title">uglify</span></span> = ( source, callback ) ->
			<span class="keyword">try</span>
				ast = jsp.parse source
				ast = pro.ast_mangle ast
				ast = pro.ast_squeeze ast
				callback <span class="literal">undefined</span>, pro.gen_code ast
			<span class="keyword">catch</span> err
				callback err, <span class="string">""</span>

		@style = <span class="keyword">new</span> StylePipeline @config, @fp, cssminifier, @scheduler, @log
		@source = <span class="keyword">new</span> SourcePipeline @config, @fp, uglify, @scheduler, @log
		@markup = {
			process: ( files, onComplete ) -> onComplete files
		}


exports.postProcessor = PostProcessor</code></pre></td></tr><tr class="block"><td class="comment"><p>docco --<br />See <a href='http://jashkenas.github.com/docco/'>http://jashkenas.github.com/docco/</a><br />docco = require "docco"</p></td><td class="code"></td></tr><tr class="block"><td class="comment"><p>ape --<br />See </p></td><td class="code"><pre><code>ape = require <span class="string">"ape"</span>
</code></pre></td></tr><tr class="block"><td class="comment"><h2>Documents</h2>

<p>A minor adaptation of @aaronmccall's docco and ape support<br />that he contributed to the prior version of Anvil.</p></td><td class="code"><pre><code><span class="keyword">class</span> Documenter
	
	constructor: ( @config, @fp, @scheduler, @log ) ->
		self = <span class="keyword">this</span>
		_.bindAll( <span class="keyword">this</span> )
		<span class="keyword">if</span> @config.docs</code></pre></td></tr><tr class="block"><td class="comment"><p>if @config.docs.generator == "docco"<br />@generator = @runDocco<br />else </p></td><td class="code"><pre><code>			@generator = @runApe
		<span class="keyword">else</span>
			@generator = () -> 
				callback = Array.prototype.slice.call arguments, <span class="number">4</span>
				<span class="keyword">if</span> callback
					callback()
</code></pre></td></tr><tr class="block"><td class="comment"><h2>generate</h2>

<p>Generate documents for the list of files<br />* <em>files {Array}</em>: the array of file objects to create documents for</p></td><td class="code"><pre><code>	generate: ( files ) ->
		self = <span class="keyword">this</span>
		<span class="keyword">if</span> files &amp;&amp; files.length > <span class="number">0</span>
			@log.onEvent <span class="string">"Creating annotated source for: <span class="subst">#{ _.pluck( files, 'name' ).toString() }</span>"</span>
			@scheduler.parallel files, @document, () ->
				self.log.onComplete <span class="string">"Code annotation completed"</span>
</code></pre></td></tr><tr class="block"><td class="comment"><h2>document</h2>

<p>Generate docco/ape annotated source for the combined file<br />Thanks much to @aaronmccall for contributing this code to Anvil!<br />* <em>file {String}</em>: the file object to create the document for<br />* <em>onComplete {Function}</em>: the function to call once the documentation is done</p></td><td class="code"><pre><code>	document: ( file, onComplete ) ->
		self = <span class="keyword">this</span>
		language = ape.get_language file.name
		ext = file.ext()
		newFile = file.name.replace ext, <span class="string">".html"</span>

		@log.onEvent <span class="string">"Annotation for <span class="subst">#{ file.name }</span>"</span>
		@fp.read [ file.workingPath, file.name ], ( content ) ->
			self.generator language, ext, newFile, content, ( doc ) ->
				self.fp.write [ self.config.docs.output, newFile ], doc, onComplete
</code></pre></td></tr><tr class="block"><td class="comment"><h2>runDoco</h2>

<p>Wraps the document generation function in docco to a standard call format<br />runDocco: ( language, extension, newFile, code, onComplete ) -><br />docco.generate_doc_from_string newFile, code, extension, ( result ) -> onComplete result</p></td><td class="code"></td></tr><tr class="block"><td class="comment"><h2>runApe</h2>

<p>Wraps the document generation function in docco to a standard call format</p></td><td class="code"><pre><code>	runApe: ( language, extension, newFile, code, onComplete ) ->
		ape.generate_doc code, language, <span class="string">'html'</span>, <span class="literal">null</span>, ( err, result ) -> onComplete result
		</code></pre></td></tr><tr class="block"><td class="comment"><h2>Anvil</h2>

<p>This provides the primary logic and flow control for build activities</p></td><td class="code"><pre><code><span class="keyword">class</span> Anvil

	constructor: ( @fp, @compiler, @combiner, @documenter, @scheduler, @postProcessor, @log, @callback ) ->
		@buildNumber = <span class="number">0</span>
		@inProcess = <span class="literal">false</span>
		
	extensions: [ <span class="string">".js"</span>, <span class="string">".coffee"</span>, <span class="string">".html"</span>, <span class="string">".haml"</span>, <span class="string">".markdown"</span>, <span class="string">".md"</span>, <span class="string">".css"</span>, <span class="string">".styl"</span>, <span class="string">".less"</span>, <span class="string">".css"</span> ]
</code></pre></td></tr><tr class="block"><td class="comment"><h2>build</h2>

<p>Kicks off the build for the currently configured Anvil instance</p></td><td class="code"><pre><code>	build: ( config ) ->
		<span class="keyword">if</span> <span class="keyword">not</span> @inProcess
			@initialize( config )
			@log.onStep <span class="string">"Build <span class="subst">#{ @buildNumber }</span> initiated"</span>
			@inProcess = <span class="literal">true</span>
			@buildSource()
			@buildStyle()
</code></pre></td></tr><tr class="block"><td class="comment"><h2>buildMarkup</h2>

<p>Builds all markup sources and provides the regex patterns used to<br />identify dependencies using regular expressions.</p></td><td class="code"><pre><code>	buildMarkup: () ->
		findPatterns = [ <span class="regexp">///[\&lt;][!][-]{2}.?import[(]?.?['\"].*['\"].?[)]?.?[-]{2}[\>]///</span>g ]
		replacePatterns = [ <span class="regexp">///([ \t]*)[\&lt;][!][-]{2}.?import[(]?.?['\"]replace['\"].?[)]?.?[-]{2}[\>]///</span>g ]
		@processType( <span class="string">"markup"</span>, findPatterns, replacePatterns )
</code></pre></td></tr><tr class="block"><td class="comment"><h2>buildSource</h2>

<p>Builds all JS and Coffee sources and provides the regex patterns used to<br />identify dependencies using regular expressions.</p></td><td class="code"><pre><code>	buildSource: () ->
		findPatterns = [ <span class="regexp">///([/]{2}|[\<span class="comment">#]{3}).?import.?[(]?.?[\"'].*[\"'].?[)]?[;]?.?([\#]{0,3})///g ]</span>
		replacePatterns = [ ///</span>([ \t]*)([/]{<span class="number">2</span>}|[\<span class="comment">#]{3}).?import.?[(]?.?[\"']replace[\"'].?[)]?[;]?.?[\#]{0,3}///g ]</span>
		@processType( <span class="string">"source"</span>, findPatterns, replacePatterns )
</code></pre></td></tr><tr class="block"><td class="comment"><h2>buildSource</h2>

<p>Builds all CSS, LESS and Stylus sources and provides the regex patterns used to<br />identify dependencies using regular expressions.</p></td><td class="code"><pre><code>	buildStyle: () ->
		findPatterns = [ <span class="regexp">///([/]{2}|[/][*]).?import[(]?.?[\"'].*[\"'].?[)]?([*][/])?///</span>g ]
		replacePatterns = [ <span class="regexp">///([ \t]*)([/]{2}|[/][*]).?import[(]?.?[\"']replace[\"'].?[)]?([*][/])?///</span>g ]
		@processType( <span class="string">"style"</span>, findPatterns, replacePatterns )
</code></pre></td></tr><tr class="block"><td class="comment"><h2>initialize</h2>

<p>Initializes state for the build</p></td><td class="code"><pre><code>	initialize: ( config ) ->
		@config = config
		@filesBuilt = {}</code></pre></td></tr><tr class="block"><td class="comment"><p>mini FSM - basically we don't want to start building markup until<br />everything else is done since markup can import other built resources</p></td><td class="code"><pre><code>		@steps = 
			source: <span class="literal">false</span>
			style: <span class="literal">false</span>
			markup: <span class="literal">false</span>
			hasSource: config.source
			hasStyle: config.style
			hasMarkup: config.markup
			markupReady: () -> ( <span class="keyword">this</span>.source <span class="keyword">or</span> <span class="keyword">not</span> <span class="keyword">this</span>.hasSource ) <span class="keyword">and</span> ( <span class="keyword">this</span>.style <span class="keyword">or</span> <span class="keyword">not</span> <span class="keyword">this</span>.hasStyle )
			allDone: () -> 
				status = ( <span class="keyword">this</span>.source <span class="keyword">or</span> <span class="keyword">not</span> <span class="keyword">this</span>.hasSource ) <span class="keyword">and</span> ( <span class="keyword">this</span>.style <span class="keyword">or</span> <span class="keyword">not</span> <span class="keyword">this</span>.hasStyle ) <span class="keyword">and</span> ( <span class="keyword">this</span>.markup <span class="keyword">or</span> <span class="keyword">not</span> <span class="keyword">this</span>.hasMarkup )
				status
</code></pre></td></tr><tr class="block"><td class="comment"><h2>processType</h2>

<p>The steps that get followed for each resource type are the same.<br />This function provides the core behavior of identifying, combining,<br />compiling and post-processing for all the types.<br />* <em>type {String}</em>: ('source', 'style', 'markup') the type of resources to process<br />* <em>findPatterns {Regex}</em>: the list of regular expressions used to identify imports in this resource type<br />* <em>replacePatterns {Regex}</em>: the list of replacement regular expressions used to replace imports with file contents</p></td><td class="code"><pre><code>	processType: ( type, findPatterns, replacePatterns ) ->
		self = <span class="keyword">this</span>
		forAll = @scheduler.parallel
		compiler = @compiler
		combiner = <span class="keyword">new</span> @combiner( @fp, @scheduler, findPatterns, replacePatterns )
		postProcessor = @postProcessor

		@log.onStep <span class="string">"Starting <span class="subst">#{ type }</span> pipe-line"</span>
		self.prepFiles type, ( list ) ->
			<span class="keyword">if</span> list <span class="keyword">and</span> list.length > <span class="number">0</span>

				self.copyFiles list, () -></code></pre></td></tr><tr class="block"><td class="comment"><p>combines imported files</p></td><td class="code"><pre><code>					self.log.onStep <span class="string">"Combining <span class="subst">#{ type }</span> files"</span>
					combiner.combineList list, () -></code></pre></td></tr><tr class="block"><td class="comment"><p>filter out all files that were combined into another file</p></td><td class="code"><pre><code>						final = _.filter( list, ( x ) -> x.dependents == <span class="number">0</span> )</code></pre></td></tr><tr class="block"><td class="comment"><p>if documentation should be generated, do that now</p></td><td class="code"><pre><code>						<span class="keyword">if</span> self.config.docs
							self.documenter.generate final</code></pre></td></tr><tr class="block"><td class="comment"><p>compiles the combined results</p></td><td class="code"><pre><code>						self.log.onStep <span class="string">"Compiling <span class="subst">#{ type }</span> files"</span>
						forAll final, compiler.compile, ( compiled ) -></code></pre></td></tr><tr class="block"><td class="comment"><p>kick off post processors for compiled files</p></td><td class="code"><pre><code>							self.log.onStep <span class="string">"Post-process <span class="subst">#{ type }</span> files"</span>
							postProcessor[ type ].process compiled, ( list ) -></code></pre></td></tr><tr class="block"><td class="comment"><p>copy complete files to the destination folders</p></td><td class="code"><pre><code>								self.log.onStep <span class="string">"Moving <span class="subst">#{ type }</span> files to destinations"</span>
								self.finalOutput list, () ->
									self.stepComplete type
			<span class="keyword">else</span>
				self.stepComplete type
</code></pre></td></tr><tr class="block"><td class="comment"><h2>finalOutput</h2>

<p>Copies the final list of files to their output folders<br />* <em>files {Array}</em>: the list of files to copy<br />* <em>onComplete {Function}</em>: the function to call once all files have been copied</p></td><td class="code"><pre><code>	finalOutput: ( files, onComplete ) ->
		fp = @fp
		names = @config.name
		forAll = @scheduler.parallel
		<span class="function"><span class="title">copy</span></span> = ( file, done ) ->
			forAll( file.outputPaths, ( destination, moved ) ->
				outputName = file.name
				<span class="keyword">if</span> names
					<span class="keyword">if</span> _.isString names 
						outputName = names
					<span class="keyword">else</span> 
						custom = names[ file.name ]
						outputName = custom <span class="keyword">or</span>= outputName
				fp.copy [ file.workingPath, file.name ], [ destination, outputName ], moved
			, done )
		forAll files, copy, onComplete
</code></pre></td></tr><tr class="block"><td class="comment"><h2>copyFiles</h2>

<p>Copies the source files to the working path before beginning any processing<br />* <em>files {Array}</em>: the list of files to copy<br />* <em>onComplete {Function}</em>: the function to call once all files have been copied</p></td><td class="code"><pre><code>	copyFiles: ( files, onComplete ) ->
		fp = @fp
		<span class="function"><span class="title">copy</span></span> = ( file, done ) -> 
			console.log <span class="string">"About to copy to <span class="subst">#{ file.workingPath }</span>/<span class="subst">#{ file.name }</span>"</span>
			src = config.source <span class="keyword">or</span> <span class="string">"src"</span>
			srcPath = path.normalize( <span class="string">"<span class="subst">#{ process.cwd() }</span>/<span class="subst">#{ src }</span>"</span> )
			dstPath = path.normalize( <span class="string">"<span class="subst">#{ process.cwd() }</span>/<span class="subst">#{ file.workingPath }</span>"</span> )
			console.log srcPath, dstPath
			fp.copy file.fullPath, file.fullPath.replace( srcPath, dstPath ), done
		@scheduler.parallel files, copy, onComplete

</code></pre></td></tr><tr class="block"><td class="comment"><h2>cleanWorking</h2>

<p>Clears all files from the working directory<br />* <em>onComplete {Function}</em>: the function to call after directory is cleaned</p></td><td class="code"><pre><code>	cleanWorking: ( onComplete ) ->
		fp = @fp
		forAll = @scheduler.parallel
		fp.getFiles @config.working, ( files ) ->
			forAll files, fp.<span class="keyword">delete</span>, () ->
				onComplete()

</code></pre></td></tr><tr class="block"><td class="comment"><h2>prepFiles</h2>

<p>Determine the list of files that belong to this particular resource type<br />and create metadata objects that describe the file and provide necessary<br />metadata to the rest of the processes.<br />* <em>type {String}</em>: ('source', 'style', 'markup') <br />* <em>onComplete {Function}</em>: the function to invoke with a completed list of file metadata</p></td><td class="code"><pre><code>	prepFiles: ( type, onComplete ) ->
		self = <span class="keyword">this</span>
		working = @config.working
		typePath = @config[ type ]
		output = @config.output[ type ]
		output = <span class="keyword">if</span> _.isArray( output ) then output <span class="keyword">else</span> [ output ]
		log = @log
		@fp.getFiles typePath, ( files ) ->
			log.onEvent <span class="string">"Found <span class="subst">#{ files.length }</span> <span class="subst">#{ type }</span> files ..."</span>
			list = <span class="keyword">for</span> file <span class="keyword">in</span> files
						name = path.basename file
						{
							dependents: <span class="number">0</span>
							ext: () -> path.extname <span class="keyword">this</span>.name
							fullPath: file
							imports: []
							name: name
							originalName: name
							outputPaths: output
							relativePath: file.replace typePath, <span class="string">""</span>
							workingPath: working
						}
			filtered = _.filter list, ( x ) -> _.any self.extensions, ( y ) -> y == x.ext()
			onComplete filtered
</code></pre></td></tr><tr class="block"><td class="comment"><h2>stepComplete</h2>

<p>Called at the end of each type's pipe-line in order to control<br />when markup gets built. Markup must get built last since it can include<br />built targets from both style and source in it's files.<br />* <em>step {String}</em>: ('source','style','markup')</p></td><td class="code"><pre><code>	stepComplete: ( step ) ->
		@steps[ step ] = <span class="literal">true</span>
		<span class="keyword">if</span> step != <span class="string">"markup"</span> <span class="keyword">and</span> @steps.markupReady()
			@buildMarkup()
		<span class="keyword">if</span> step == <span class="string">"markup"</span> <span class="keyword">and</span> @steps.allDone()
			@inProcess = <span class="literal">false</span>
			@cleanWorking @callback
				
</code></pre></td></tr><tr class="block"><td class="comment"><h2>Continuous</h2>

<p>Provides a way to trigger the build on file change</p></td><td class="code"><pre><code><span class="keyword">class</span> Continuous

	constructor: ( @fp, @config, @onChange ) ->
		@style = @normalize @config.style
		@source = @normalize @config.source
		@markup = @normalize @config.markup
		@spec = @normalize @config.spec
		@watchers = []
		@watching = <span class="literal">false</span>
		_.bindAll( <span class="keyword">this</span> )
		<span class="keyword">this</span>
</code></pre></td></tr><tr class="block"><td class="comment"><h2>normalize</h2>

<p>Takes an input and, if it is an array, returns the plain array<br />if the input is not an array, it turns it into a single element array<br />* <em>x {Object}</em>: anything</p></td><td class="code"><pre><code>	normalize: ( x ) -> <span class="keyword">if</span> _.isArray x then x <span class="keyword">else</span> [ x ]
</code></pre></td></tr><tr class="block"><td class="comment"><h2>setup</h2>

<p>Determines which directories should cause a build to trigger<br />if any contents change</p></td><td class="code"><pre><code>	setup: () ->
		<span class="keyword">if</span> <span class="keyword">not</span> @watching
			@watching = <span class="literal">true</span>
			<span class="keyword">if</span> @style then @watchPath p <span class="keyword">for</span> p <span class="keyword">in</span> @style
			<span class="keyword">if</span> @source then @watchPath p <span class="keyword">for</span> p <span class="keyword">in</span> @source
			<span class="keyword">if</span> @markup then @watchPath p <span class="keyword">for</span> p <span class="keyword">in</span> @markup
			<span class="keyword">if</span> @spec then @watchPath p <span class="keyword">for</span> p <span class="keyword">in</span> @spec
</code></pre></td></tr><tr class="block"><td class="comment"><h2>watchpath</h2>

<p>Calls watchFiles for all files in the path<br />* <em>path {String/Array}</em>: the path specification to watch for changes in</p></td><td class="code"><pre><code>	watchPath: ( path ) ->
		@fp.getFiles path, @watchFiles
</code></pre></td></tr><tr class="block"><td class="comment"><h2>watchFiles</h2>

<p>Creates a file watcher instance for all files in the list<br />* <em>files {Array}</em>: the list of files to watch for changes in</p></td><td class="code"><pre><code>	watchFiles: ( files ) ->
		<span class="keyword">for</span> file <span class="keyword">in</span> files
			@watchers.push fs.watch file, @onEvent
</code></pre></td></tr><tr class="block"><td class="comment"><h2>onEvent</h2>

<p>This handler triggers the build and closes all watchers in the event <br />of a change. This is necessary to prevent event storms that can trigger <br />during the build process.<br />* <em>event {Object}</em>: the event that fired on the file system<br />* <em>file {String}</em>: the file that triggered the change</p></td><td class="code"><pre><code>	onEvent: ( event, file ) ->
		<span class="keyword">if</span> @watching
			@watching = <span class="literal">false</span>
			<span class="keyword">while</span> @watchers.length > <span class="number">0</span>
				@watchers.pop().close()
			@onChange()

mocha = require <span class="string">"mocha"</span>
_ = require <span class="string">"underscore"</span>
reporters = mocha.reporters
interfaces = mocha.interfaces
Context = mocha.Context
Runner = mocha.Runner
Suite = mocha.Suite
path = require <span class="string">"path"</span>
</code></pre></td></tr><tr class="block"><td class="comment"><pre><code>This class is an adaptation of the code found in _mocha
from TJ Holowaychuk's Mocha repository:
<a href='https://github.com/visionmedia/mocha/blob/master/bin/_mocha'>https://github.com/visionmedia/mocha/blob/master/bin/_mocha</a>
</code></pre></td><td class="code"><pre><code><span class="keyword">class</span> MochaRunner

	constructor: ( @fp, @scheduler, @config, @onComplete ) ->
		_.bindAll( <span class="keyword">this</span> )
		
	run: () ->
		self = <span class="keyword">this</span>
		<span class="keyword">if</span> @config.spec
			forAll = @scheduler.parallel
			filesIn = @fp.getFiles

			opts = @config.mocha <span class="keyword">or</span>=
				growl: <span class="literal">true</span>
				ignoreLeaks: <span class="literal">true</span>
				reporter: <span class="string">"spec"</span>
				ui: <span class="string">"bdd"</span>
				colors: <span class="literal">true</span>

			reporterName = opts.reporter.toLowerCase().replace( <span class="regexp">///([a-z])///</span>, ( x ) -> x.toUpperCase() )
			uiName = opts.ui.toLowerCase()

			suite = <span class="keyword">new</span> Suite <span class="string">''</span>, <span class="keyword">new</span> Context
			Base = reporters.Base
			Reporter = reporters[reporterName]
			ui = interfaces[uiName]( suite )
			<span class="keyword">if</span> opts.colors then Base.useColors = <span class="literal">true</span>
			<span class="keyword">if</span> opts.slow then Base.slow = opts.slow
			<span class="keyword">if</span> opts.timeout then suite.timeout opts.timeout

			specs = <span class="keyword">if</span> _.isString @config.spec then [ @config.spec ] <span class="keyword">else</span> @config.spec

			forAll specs, @fp.getFiles, ( lists ) ->
				self.cleanUp()
				files = _.flatten lists
				<span class="keyword">for</span> file <span class="keyword">in</span> files
					suite.emit <span class="string">'pre-require'</span>, global, file
					suite.emit <span class="string">'require'</span>, require file, file
					suite.emit <span class="string">'post-require'</span>, global, file

				suite.emit <span class="string">'run'</span>
				runner = <span class="keyword">new</span> Runner suite
				reporter = <span class="keyword">new</span> Reporter runner
				<span class="keyword">if</span> opts.ignoreLeaks then runner.ignoreLeaks = <span class="literal">true</span>
				runner.run () -> 
					cachedFiles = _.flatten require.cache
					sourcePath = path.resolve self.config.source
					pathLength = sourcePath.length
					<span class="keyword">for</span> file <span class="keyword">in</span> cachedFiles
						modulePath = file.filename.substring <span class="number">0</span>, pathLength
						<span class="keyword">if</span> sourcePath == modulePath
							<span class="keyword">delete</span> require.cache[ file ]
					self.onComplete()

	cleanUp: () ->
		cachedFiles = _.flatten require.cache
		sourcePath = path.resolve @config.source
		pathLength = sourcePath.length
		<span class="keyword">for</span> file <span class="keyword">in</span> cachedFiles
			modulePath = file.filename.substring <span class="number">0</span>, pathLength
			<span class="keyword">if</span> sourcePath == modulePath
				<span class="keyword">delete</span> require.cache[ file ]
</code></pre></td></tr><tr class="block"><td class="comment"><h2>SocketServer</h2>

<p>Class to manage client notifications via socket.io</p></td><td class="code"><pre><code><span class="keyword">class</span> SocketServer
	
	constructor: ( app ) ->
		_.bindAll( <span class="keyword">this</span> )
		@clients = []
		@io = require( <span class="string">"socket.io"</span> ).listen(app)
		@io.set <span class="string">"log level"</span>, <span class="number">1</span></code></pre></td></tr><tr class="block"><td class="comment"><p>When a "connection" event occurs, call <em>@addClient</em></p></td><td class="code"><pre><code>		@io.sockets.<span class="literal">on</span> <span class="string">"connection"</span>, @addClient
</code></pre></td></tr><tr class="block"><td class="comment"><h2>addClient</h2>

<p>Adds a new client to be notified upon change to watched files</p>

<h3>Args:</h3>

<ul>
<li><em>socket {Object}</em>: Socket object that is generated by a socket.io 
connection event.</li>
</ul></td><td class="code"><pre><code>	addClient: ( socket ) ->
		@clients.push socket
		socket.<span class="literal">on</span> <span class="string">"end"</span>, @removeClient
		socket.<span class="literal">on</span> <span class="string">"disconnect"</span>, @removeClient
		log.onEvent <span class="string">"client connected"</span>
</code></pre></td></tr><tr class="block"><td class="comment"><h2>removeClient</h2>

<p>Removes the socket from the current list of connected sockets<br />* <em>socket {Object}</em>: the socket that has disconnected</p></td><td class="code"><pre><code>	removeClient: ( socket ) ->
		index = @clients.indexOf socket
		@clients.splice index, <span class="number">1</span>
		log.onEvent <span class="string">"client disconnected"</span>
</code></pre></td></tr><tr class="block"><td class="comment"><h2>refreshClient</h2>

<p>Sends a 'refresh' message to all connected clients</p></td><td class="code"><pre><code>	refreshClients: ->
		log.onEvent <span class="string">"Refreshing hooked clients"</span>
		@notifyClients <span class="string">"refresh"</span>
</code></pre></td></tr><tr class="block"><td class="comment"><h2>notifyClients</h2>

<p>Send a message to all connected clients<br />* <em>msg {String}</em>: the message to send to connected clients</p></td><td class="code"><pre><code>	notifyClients: ( msg ) ->
		<span class="keyword">for</span> client <span class="keyword">in</span> @clients
			client.emit msg, {}
express = require <span class="string">'express'</span>
</code></pre></td></tr><tr class="block"><td class="comment"><h2>Host</h2>

<p>This class provides a simple static HTTP server<br />that can support all supported files types for Anvil<br />builds</p></td><td class="code"><pre><code><span class="keyword">class</span> Host

	constructor: ( @fp, @scheduler, @compiler, @config ) ->
		self = <span class="keyword">this</span>
		_.bindAll( <span class="keyword">this</span> )

		@app = express.createServer()
		app = @app
		app.use express.bodyParser()
		app.use app.router

		hosts = @config.hosts</code></pre></td></tr><tr class="block"><td class="comment"><p>if the user told us what to do, make no assumptions<br />only host exactly what they specify</p></td><td class="code"><pre><code>		<span class="keyword">if</span> hosts
			_.each( hosts, ( value, key ) ->
				app.use key, express.static( path.resolve value )
			)</code></pre></td></tr><tr class="block"><td class="comment"><p>otherwise, let's have some fun...</p></td><td class="code"><pre><code>		<span class="keyword">else</span> 
			output = @config.output
			target = <span class="string">""</span>
			<span class="keyword">if</span> @config.markup <span class="comment"># this is a site</span>
				<span class="keyword">if</span> _.isString output 
					target = output
				<span class="keyword">else</span> <span class="keyword">if</span> _.isArray output
					target = output[ <span class="number">0</span> ]
				<span class="keyword">else</span>
					target = output.markup
			<span class="keyword">else</span> <span class="comment"># this is a lib</span>
				<span class="keyword">if</span> _.isString output 
					target = output
				<span class="keyword">else</span> <span class="keyword">if</span> _.isArray output
					target = output[ <span class="number">0</span> ]
				<span class="keyword">else</span>
					target = output.source
			app.use <span class="string">"/"</span>, express.static( path.resolve target )

		<span class="keyword">if</span> @config.ext
			app.use <span class="string">"/ext"</span>, express.static( path.resolve @config.ext )
		<span class="keyword">if</span> @config.spec
			app.use <span class="string">"/spec"</span>, express.static( path.resolve @config.spec )
</code></pre></td></tr><tr class="block"><td class="comment"><p>host anvil prerequisites for supporting certain browser features out of<br />the box</p></td><td class="code"><pre><code>		anvilPath = path.resolve( path.dirname( fs.realpathSync( __filename ) ), <span class="string">"../ext"</span> )
		console.log <span class="string">"Hosting anvil prerequisites from <span class="subst">#{ anvilPath }</span>"</span>
		app.use <span class="string">"/anvil"</span>, express.static( anvilPath )
</code></pre></td></tr><tr class="block"><td class="comment"><p>if a static file type is requested that fits an extension we know how to<br />compile, use the compiler to translate it on-the-fly</p></td><td class="code"><pre><code>		app.get <span class="regexp">///.*[.](coffee|kup|less|styl|md|markdown|haml)///</span>, ( req, res ) ->
			fileName = <span class="string">".<span class="subst">#{ req.url }</span>"</span>

			ext = path.extname fileName
			mimeType = self.contentTypes[ ext ]
			res.header <span class="string">'Content-Type'</span>, mimeType
			self.fp.read fileName, ( content ) ->
				self.compiler.compilers[ ext ] content, ( compiled ) ->
					res.send compiled

		port = <span class="keyword">if</span> @config.port then @config.port <span class="keyword">else</span> <span class="number">3080</span>
		app.listen port

	contentTypes:
		<span class="string">".coffee"</span>: <span class="string">"application/javascript"</span>
		<span class="string">".less"</span>: <span class="string">"text/css"</span>
		<span class="string">".styl"</span>: <span class="string">"text/css"</span>
		<span class="string">".md"</span>: <span class="string">"text/html"</span>
		<span class="string">".markdown"</span>: <span class="string">"text/html"</span>
		<span class="string">".haml"</span>: <span class="string">"text/html"</span>
		<span class="string">".kup"</span>: <span class="string">"text/html"</span></code></pre></td></tr><tr class="block"><td class="comment"><h1>Cli</h1>

<p>Provides the command line interface for interacting with Anvil and related modules</p></td><td class="code"><pre><code><span class="keyword">class</span> Cli

	constructor: () ->
		@anvil = {}
		
		@ci = <span class="literal">undefined</span>
		@documenter = <span class="literal">undefined</span>
		@mochaRunner = <span class="literal">undefined</span>
		@socketServer = {}
		@postProcessor = {}
		@log = log
		@scheduler = <span class="keyword">new</span> Scheduler()
		@crawler = <span class="keyword">new</span> FSCrawler @scheduler
		@fp = <span class="keyword">new</span> FSProvider @crawler, @log
		@configuration = <span class="keyword">new</span> Configuration @fp, @scheduler, @log
		@compiler = <span class="keyword">new</span> Compiler @fp, @log

		_.bindAll <span class="keyword">this</span>

	initCI: ( config ) ->
		@ci = <span class="keyword">new</span> Continuous @fp, config, @onFileChange

	initHost: ( config ) ->
		@server = <span class="keyword">new</span> Host @fp, @scheduler, @compiler, config
		@socketServer = <span class="keyword">new</span> SocketServer @server.app
		@log.onStep <span class="string">"Static HTTP server listening on port <span class="subst">#{ config.port }</span>"</span>

	initMocha: ( config ) ->
		@mochaRunner = <span class="keyword">new</span> MochaRunner @fp, @scheduler, config, @onTestsComplete

	notifyHttpClients: () ->
		<span class="keyword">if</span> @socketServer.refreshClients
			@log.onStep <span class="string">"Notifying clients of build completion"</span>
			@socketServer.refreshClients()

	onBuildComplete: () ->
		self = <span class="keyword">this</span>
		@log.onComplete <span class="string">"Build <span class="subst">#{ @anvil.buildNumber++ }</span> completed"</span>
		<span class="keyword">if</span> self.mochaRunner</code></pre></td></tr><tr class="block"><td class="comment"><p>wrap the mocha runner invocation in a timeout call<br />to prevent odd timing issues.</p></td><td class="code"><pre><code>			self.log.onStep <span class="string">"Running specifications with Mocha"</span>
			self.mochaRunner.run()
		<span class="keyword">else</span> 
			self.startCI()
			self.notifyHttpClients()

	onConfig: ( config, stop ) ->
		@config = config</code></pre></td></tr><tr class="block"><td class="comment"><p>if stop comes back, then this is not a build and we're done</p></td><td class="code"><pre><code>		<span class="keyword">if</span> stop then process.exit <span class="number">0</span>
		</code></pre></td></tr><tr class="block"><td class="comment"><p>if the user wants CI, setup the continuous module</p></td><td class="code"><pre><code>		<span class="keyword">if</span> config.continuous then @initCI config
			</code></pre></td></tr><tr class="block"><td class="comment"><p>if the user wants mocha to run after the build, setup the mocha runner</p></td><td class="code"><pre><code>		<span class="keyword">if</span> config.mocha then @initMocha config
</code></pre></td></tr><tr class="block"><td class="comment"><p>if the user wants hosting then, spin up the Static HTTP host and socket server</p></td><td class="code"><pre><code>		<span class="keyword">if</span> config.host then @initHost config
</code></pre></td></tr><tr class="block"><td class="comment"><p>create the post processor instance</p></td><td class="code"><pre><code>		@postProcessor = <span class="keyword">new</span> PostProcessor config, @fp, @scheduler, @log
		@documenter = <span class="keyword">new</span> Documenter config, @fp, @scheduler, @log
		@anvil = <span class="keyword">new</span> Anvil @fp, @compiler, Combiner, @documenter, @scheduler, @postProcessor, @log, @onBuildComplete

		@anvil.build( config )</code></pre></td></tr><tr class="block"><td class="comment"><p>if we're using CI, kick it off the first time</p></td><td class="code"><pre><code>		@startCI()

	onFileChange: () ->
		@log.onEvent <span class="string">"File change detected, starting build"</span>
		@<span class="function"><span class="title">fileChange</span></span> = ->
		@anvil.build( @config )

	onTestsComplete: () ->
		@log.onComplete <span class="string">"Tests completed"</span>
		@startCI()
		@notifyHttpClients()
	
	run: () ->
		@configuration.configure process.argv, @onConfig

	startCI: () ->
		<span class="keyword">if</span> @ci
			@log.onStep <span class="string">"Starting file watchers"</span>
			@ci.setup()
			

exports.<span class="function"><span class="title">run</span></span> = ->
	cli = <span class="keyword">new</span> Cli()
	cli.run()

</code></pre></td></tr></table></body>