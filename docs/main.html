<!DOCTYPE html><head><style type="text/css">pre code{display:block;padding:.5em;color:black;background:#f8f8ff}pre .comment,pre .template_comment,pre .diff .header,pre .javadoc{color:#998;font-style:italic}pre .keyword,pre .css .rule .keyword,pre .winutils,pre .javascript .title,pre .lisp .title,pre .subst{color:black;font-weight:bold}pre .number,pre .hexcolor{color:#40a070}pre .string,pre .tag .value,pre .phpdoc,pre .tex .formula{color:#d14}pre .title,pre .id{color:#900;font-weight:bold}pre .javascript .title,pre .lisp .title,pre .subst{font-weight:normal}pre .class .title,pre .haskell .label,pre .tex .command{color:#458;font-weight:bold}pre .tag,pre .tag .title,pre .rules .property,pre .django .tag .keyword{color:navy;font-weight:normal}pre .attribute,pre .variable,pre .instancevar,pre .lisp .body{color:teal}pre .regexp{color:#009926}pre .class{color:#458;font-weight:bold}pre .symbol,pre .ruby .symbol .string,pre .ruby .symbol .keyword,pre .ruby .symbol .keymethods,pre .lisp .keyword,pre .tex .special,pre .input_number{color:#990073}pre .builtin,pre .built_in,pre .lisp .title{color:#0086b3}pre .preprocessor,pre .pi,pre .doctype,pre .shebang,pre .cdata{color:#999;font-weight:bold}pre .deletion{background:#fdd}pre .addition{background:#dfd}pre .diff .change{background:#0086b3}pre .chunk{color:#aaa}pre .tex .formula{opacity:.5}#docs {margin:auto}.block {clear:both}.comment {padding: 0 10px;width:50%;background:snow}.code {width:49%;background:#f8f8ff}td {vertical-align:top}table {width:90%; border-collapse:collapse}
</style></head><body><table id="docs"><tr class="block"><td class="comment"><h2>run</h2>

<p>The public api called by bin/anvil</p></td><td class="code"><pre><code><span class="reserved">export</span>s.run = <span class="function">-></span>
    configure<span class="params">()</span>

</code></pre></td></tr><tr class="block"><td class="comment"><h2>process</h2>

<p>Checks to see if process is already running and squawks if it is.<br />If not:<br />Makes sure paths are setup, then calls <em>crawlFiles</em></p></td><td class="code"><pre><code>process = <span class="params">()</span> <span class="function">-></span>
    <span class="keyword">unless</span> inProcess
        inProcess = <span class="literal">true</span>
        <span class="keyword">try</span>
          ensurePaths <span class="function">-></span> crawlFiles<span class="params">()</span>
        <span class="keyword">catch</span> ex
          inProcess = <span class="literal">false</span>
          onError <span class="string">"The build failed failingly. Like a failure :@"</span>
    <span class="keyword">else</span>
      onError <span class="string">"There is already a build in process"</span>
</code></pre></td></tr><tr class="block"><td class="comment"><h2>crawlFiles</h2>

<p>Runs <em>parseSource</em> on all files in the dir defined by <em>config.source</em><br />then runs <em>createTransforms</em> on each of the file metadata objects that it created and <br />finally runs <em>transform</em> on the resulting list of files</p></td><td class="code"><pre><code>crawlFiles = <span class="params">()</span> <span class="function">-></span></code></pre></td></tr><tr class="block"><td class="comment"><p>Iterate the files, running <em>parseSource</em> on each and appending the result<br />to <em>combineList</em>.</p></td><td class="code"><pre><code>  forFilesIn config.source, parseSource, <span class="params">(combineList)</span> <span class="function">-></span>
      onEvent <span class="string">"<span class="subst">#{combineList.length}</span> files parsed."</span>
      transformer = <span class="params">( item, done )</span> <span class="function">-></span> createTransforms item, combineList, done</code></pre></td></tr><tr class="block"><td class="comment"><p>Iterate the list of file descriptor objects from</p></td><td class="code"><pre><code>      forAll combineList, transformer, transform
  inProcess = <span class="literal">false</span>

</code></pre></td></tr><tr class="block"><td class="comment"><h2>transform</h2>

<p>Iterates full list of file metadata objects, after their include transforms<br />have been created, importing the includes (<em>combine</em>) and passing the resulting<br />list to <em>pack</em></p>

<h3>Args:</h3>

<ul>
<li><em>withTransforms {Array}</em>: list of files that have had their include 
functions generated and added</li>
</ul></td><td class="code"><pre><code>transform = <span class="params">( withTransforms)</span><span class="function">-></span>
  analyzed = rebuildList <span class="reserved">with</span>Transforms
  combiner = <span class="params">( file, done )</span> <span class="function">-></span> combine<span class="params">( file, analyzed, done )</span>
  forAll analyzed, combiner, pack

</code></pre></td></tr><tr class="block"><td class="comment"><h2>pack</h2>

<p>Runs <em>wrap</em>, <em>lint</em>, <em>uglify</em> (minification), <em>gzip</em> and <em>finalize</em> steps on<br />the list of combined files (after removing include files) then regenerates<br />test page and continuous integration watches (if relevant).</p>

<h3>Args:</h3>

<ul>
<li><em>combined {Array}</em>: list of combined (includes included) files</li>
</ul></td><td class="code"><pre><code>pack = <span class="params">( combined)</span><span class="function">-></span></code></pre></td></tr><tr class="block"><td class="comment"><p>Remove all includes from the list </p></td><td class="code"><pre><code>  buildList = removeIntermediates combined</code></pre></td></tr><tr class="block"><td class="comment"><p>Apply wrapper to final output files, if supposed to</p></td><td class="code"><pre><code>  forAll _.pluck<span class="params">( buildList, <span class="string">"file"</span> )</span>, wrap, <span class="params">(wrapped)</span> <span class="function">-></span></code></pre></td></tr><tr class="block"><td class="comment"><p>Do any file renaming that should be done</p></td><td class="code"><pre><code>      forAll wrapped, renameFile, <span class="params">(renamed)</span> <span class="function">-></span></code></pre></td></tr><tr class="block"><td class="comment"><p>Lint all files</p></td><td class="code"><pre><code>        forAll renamed, lint, <span class="params">(passed)</span> <span class="function">-></span></code></pre></td></tr><tr class="block"><td class="comment"><p>Uglify all files, if configured to</p></td><td class="code"><pre><code>            forAll passed, uglify, <span class="params">(uggered)</span> <span class="function">-></span></code></pre></td></tr><tr class="block"><td class="comment"><p>Gzip all files, if configured to</p></td><td class="code"><pre><code>                forAll uggered, gzip, <span class="params">(gzipped)</span> <span class="function">-></span></code></pre></td></tr><tr class="block"><td class="comment"><p>Apply finalize wrapper to all gzipped and uglified files</p></td><td class="code"><pre><code>                    forAll gzipped, finalize, <span class="params">(finalized)</span> <span class="function">-></span>
                      onComp<span class="reserved">let</span>e <span class="string">"Output: "</span> + finalized.toString<span class="params">()</span>
                      inProcess = <span class="literal">false</span>
                      gendocs<span class="params">()</span></code></pre></td></tr><tr class="block"><td class="comment"><p>If configured to test, regenerate test page.</p></td><td class="code"><pre><code>                      <span class="keyword">if</span> test
                        createPage<span class="params">()</span></code></pre></td></tr><tr class="block"><td class="comment"><p>If configured for CI, setup file watches</p></td><td class="code"><pre><code>                      <span class="keyword">if</span> continuous
                        createWatch<span class="params">()</span>
</code></pre></td></tr><tr class="block"><td class="comment"><h2>compileCoffee</h2>

<p>Compiles CoffeeScript <em>file</em> to a Javascript file</p>

<h3>Args:</h3>

<ul>
<li><em>sourcePath {String}</em>: directory pathspec where <em>file</em> is located</li>
<li><em>file {String}</em>: filename to compile</li>
</ul></td><td class="code"><pre><code>compileCoffee = <span class="params">( sourcePath, file )</span> <span class="function">-></span>
    jsFile = file.replace <span class="string">".coffee"</span>, <span class="string">".js"</span>
    coffeeFile = path.join sourcePath, file
    transformFileSync<span class="params">(
        coffeeFile,
        ( x )</span> <span class="function">-></span>
          <span class="keyword">try</span>
            coffeeScript.compile x, { bare: <span class="literal">true</span> }
          <span class="keyword">catch</span> error
            inProcess = <span class="literal">false</span>
        [ config.tmp, jsFile ],
        <span class="params">( x )</span> <span class="function">-></span> x == x
    )
    jsFile

</code></pre></td></tr><tr class="block"><td class="comment"><h2>parseSource</h2>

<p>Creates a metadata object for CoffeeScript/JavaScript <em>file</em></p>

<h3>Args:</h3>

<ul>
<li><em>sourcePath {String}</em>: directory pathspec where <em>file</em> is located</li>
<li><em>file {String}</em>: filename to parse</li>
<li><em>parsed {Function}</em>: what to do with <em>file</em>'s metadata</li>
</ul></td><td class="code"><pre><code>parseSource = <span class="params">( sourcePath, file, parsed )</span> <span class="function">-></span>
    filePath = path.join sourcePath, file
    onEvent <span class="string">"Parsing <span class="subst">#{filePath}</span>"</span>
    <span class="keyword">if</span> <span class="params">(file.substr file.length - <span class="number">6</span>)</span> == <span class="string">"coffee"</span> <span class="keyword">and</span> <span class="keyword">not</span> config.justCoffee</code></pre></td></tr><tr class="block"><td class="comment"><p>This is a CoffeeScript file and we are supposed to end up with Javascript</p></td><td class="code"><pre><code>        <span class="keyword">try</span></code></pre></td></tr><tr class="block"><td class="comment"><p>Compile to Javascript then re-run <em>parseSource</em> on the Javascript file</p></td><td class="code"><pre><code>          file = compileCoffee sourcePath, file
          parseSource config.tmp, file, parsed
        <span class="keyword">catch</span> ex
          inProcess = <span class="literal">false</span>
    <span class="keyword">else</span>
        readFile filePath, <span class="params">( content )</span> <span class="function">-></span></code></pre></td></tr><tr class="block"><td class="comment"><p>Detect if this file has any anvil import statements</p></td><td class="code"><pre><code>            <span class="reserved">import</span>s = content.match <span class="reserved">import</span>Regex
            count = <span class="reserved">import</span>s?.length
            <span class="keyword">if</span> <span class="reserved">import</span>s</code></pre></td></tr><tr class="block"><td class="comment"><p>The file does have import statements. Let's collect them!</p></td><td class="code"><pre><code>                files = ( (target.match ///[\"].*[\"]///)[0] for target in imports )
                files = ( x.replace(///[\"]///g,'') for x in files )
                unless config.justCoffee
                    files = ( x.replace(".coffee", ".js") for x in files )
                onEvent "   - #{x}" for x in files</code></pre></td></tr><tr class="block"><td class="comment"><p>Call parsed callback with the parsed output including includes (imports)</p></td><td class="code"><pre><code>                parsed { fullPath: filePath, file: file, path: sourcePath, includes: files, combined: <span class="literal">false</span> }
            <span class="keyword">else</span></code></pre></td></tr><tr class="block"><td class="comment"><p>Call parsed callback with the parsed output </p></td><td class="code"><pre><code>                parsed { fullPath: filePath, file: file, path: sourcePath, includes: [], combined: <span class="literal">false</span> }

</code></pre></td></tr><tr class="block"><td class="comment"><h2>createTransforms</h2>

<p>Builds transform functions for all of a file's includes using <em>buildTransforms</em>.</p>

<h3>Args:</h3>

<ul>
<li><em>item {Object}</em>: file metadata object (result of <em>parseSource</em>)</li>
<li><em>list {Array}</em>: full list of file metadata objects created by <em>parseSource</em></li>
<li><em>done {Function}</em>: next step in the process. Consumes </li>
</ul></td><td class="code"><pre><code>createTransforms = <span class="params">( item, list, done )</span> <span class="function">-></span>
    <span class="keyword">if</span> item.includes.length == <span class="number">0</span>
        done item
    forAll item.includes,
            <span class="params">(include, onTx)</span> <span class="function">-></span> buildTransforms<span class="params">( include, item, list, onTx )</span>,
            <span class="params">(transforms)</span> <span class="function">-></span>
                item.transforms = transforms
                done item

</code></pre></td></tr><tr class="block"><td class="comment"><h2>buildTransforms</h2>

<p>Checks to see that a given <em>include</em> (###|// import...) has a matching file in the file list<br />then creates import transform function for it.</p>

<h3>Args:</h3>

<ul>
<li><em>include {String}</em>: name of file to include</li>
<li><em>item {Object}</em>: file metadata object (result of <em>parseSource</em>)</li>
<li><em>list {Array}</em>: full list of file metadata objects created by <em>parseSource</em></li>
<li><em>done {Function}</em>: pass result to next step in the process. </li>
</ul></td><td class="code"><pre><code>buildTransforms = <span class="params">( include, item, list, done )</span> <span class="function">-></span>
    includePattern = include.replace<span class="params">(<span class="string">".coffee"</span>,<span class="string">""</span>)</span>.replace<span class="params">(<span class="string">".js"</span>,<span class="string">""</span>)</span> + <span class="string">"[.](js|coffee)"</span>
    pattern = <span class="keyword">new</span> RegExp<span class="params">(<span class="string">"([/].|[#]{1,3})import[( ][\"]"</span> + includePattern + <span class="string">"[\"][ )]?[;]?([*/]{2})?[#]{0,3}"</span>,<span class="string">"g"</span>)</span>
    includedItem = _.detect list, <span class="params">( file_meta )</span> <span class="function">-></span> file_meta.file == include
    outputPath = config.source
    <span class="keyword">if</span> includedItem
        outputPath = config.output</code></pre></td></tr><tr class="block"><td class="comment"><p>Get the full pathspec for <em>include</em></p></td><td class="code"><pre><code>    filePath = path.join outputPath, include
    onStep <span class="string">"Building transform for <span class="subst">#{filePath}</span>"</span></code></pre></td></tr><tr class="block"><td class="comment"><p>Adds the import transform function to <em>item</em>'s include list</p></td><td class="code"><pre><code>    done <span class="params">(file_contents)</span> <span class="function">-></span></code></pre></td></tr><tr class="block"><td class="comment"><p>Retrieve <em>include</em>'s contents</p></td><td class="code"><pre><code>        content = fs.readFileSync filePath, <span class="string">"utf8"</span></code></pre></td></tr><tr class="block"><td class="comment"><p>Insert <em>content</em> in place of the import statement.</p></td><td class="code"><pre><code>        file_contents.replace pattern, content

</code></pre></td></tr><tr class="block"><td class="comment"><h2>rebuildList</h2>

<p>Clean up the the list of file metadata, eliminating empty members.</p>

<h3>Args:</h3>

<ul>
<li><em>list {Array}</em>: full list of file metadata objects created by <em>parseSource</em></li>
</ul></td><td class="code"><pre><code>rebuildList = <span class="params">( list)</span> <span class="function">-></span></code></pre></td></tr><tr class="block"><td class="comment"><p>Iterate <em>list</em> detecting any uses of a file by other files as an include</p></td><td class="code"><pre><code>    list = <span class="params">( findUses file, list <span class="keyword">for</span> file <span class="keyword">in</span> list )</span></code></pre></td></tr><tr class="block"><td class="comment"><p>Return only entries that are not undefined.</p></td><td class="code"><pre><code>    _.select list, <span class="params">( x )</span> <span class="function">-></span> x <span class="keyword">isnt</span> <span class="literal">undefined</span>

</code></pre></td></tr><tr class="block"><td class="comment"><h2>findUses</h2>

<p>Finds uses of a given file (<em>item</em>) as an include by the other files in <em>list</em>.</p>

<h3>Args:</h3>

<ul>
<li><em>item {Object}</em>: file metadata object (result of <em>parseSource</em>)</li>
<li><em>list {Array}</em>: full list of file metadata objects created by <em>parseSource</em></li>
</ul></td><td class="code"><pre><code>findUses = <span class="params">( item, list )</span> <span class="function">-></span>
    <span class="keyword">unless</span> item
        <span class="literal">undefined</span>
    <span class="keyword">else</span></code></pre></td></tr><tr class="block"><td class="comment"><p>Compile a list of files in <em>list</em> that include <em>item</em>.</p></td><td class="code"><pre><code>        uses = _.select list, <span class="params">( file )</span> <span class="function">-></span> </code></pre></td></tr><tr class="block"><td class="comment"><p>Return true if any of <em>file</em>'s includes is <em>item</em>.</p></td><td class="code"><pre><code>            _.any file.includes, <span class="params">( include )</span> <span class="function">-></span> 
                item.file == include
        count = uses?.length
        item.used = count <span class="keyword">or</span>= <span class="number">0</span>
        item

</code></pre></td></tr><tr class="block"><td class="comment"><h2>combine</h2>

<p>Combine all files with their includes.</p>

<h3>Args:</h3>

<ul>
<li><em>item {Object}</em>: file metadata object (result of <em>parseSource</em>)</li>
<li><em>list {Array}</em>: full list of file metadata objects created by <em>parseSource</em></li>
<li><em>done {Function}</em>: pass result to next step in the process.</li>
</ul></td><td class="code"><pre><code>combine = <span class="params">( item, list, done )</span> <span class="function">-></span></code></pre></td></tr><tr class="block"><td class="comment"><p>If <em>item</em> has already been combined, return early</p></td><td class="code"><pre><code>    <span class="keyword">if</span> item.combined
        <span class="keyword">return</span> item.combined
    onStep <span class="string">"Combining <span class="subst">#{item.fullPath}</span> and its includes"</span></code></pre></td></tr><tr class="block"><td class="comment"><p>Ensure that all of <em>item</em>'s includes have all of their includes imported</p></td><td class="code"><pre><code>    precombineIncludes item.includes, list, done

    output = path.join config.output, item.file
</code></pre></td></tr><tr class="block"><td class="comment"></td><td class="code"><pre><code>    transformFileSync<span class="params">(
        item.fullPath,
        ( file_contents )</span> <span class="function">-></span>
            <span class="keyword">if</span> item.transforms
                file_contents = transform<span class="params">( file_contents )</span> <span class="keyword">for</span> transform <span class="keyword">in</span> item.transforms
            file_contents
        ,
        output,
        <span class="params">( x )</span> <span class="function">-></span>
            item.file = output
            item.combined = <span class="literal">true</span>
            done item
    )
</code></pre></td></tr><tr class="block"><td class="comment"><h2>precombineIncludes</h2>

<p>Ensure that all includes have imported their includes before they are <br />imported themselves.</p>

<h3>Args:</h3>

<ul>
<li><em>includes</em> {Array}: list of includes from a file metadata object</li>
<li><em>list {Array}</em>: full list of file metadata objects created by <em>parseSource</em></li>
<li><em>done {Function}</em>: pass result to next step in the process. </li>
</ul></td><td class="code"><pre><code>precombineIncludes = <span class="params">( includes, list, done )</span> <span class="function">-></span></code></pre></td></tr><tr class="block"><td class="comment"><p>Return list of_includes_ that have not yet imported their own includes</p></td><td class="code"><pre><code>    items = _.select list, <span class="params">( file_meta )</span> <span class="function">-></span> </code></pre></td></tr><tr class="block"><td class="comment"><p>Return true if any include has not been combined</p></td><td class="code"><pre><code>        _.any includes, <span class="params">( include )</span> <span class="function">-></span> </code></pre></td></tr><tr class="block"><td class="comment"><p>Return true if <em>include</em> has not been combined (imported includes)</p></td><td class="code"><pre><code>            include == file_meta.file <span class="keyword">and</span> <span class="keyword">not</span> file_meta.combined</code></pre></td></tr><tr class="block"><td class="comment"><p>Combine all the includes with their imports</p></td><td class="code"><pre><code>    combine file, list, done <span class="keyword">for</span> file <span class="keyword">in</span> items
</code></pre></td></tr></table></body>