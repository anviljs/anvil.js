# ## ClientNotifier ##
# Class to manage client notifications via socket.io
class ClientNotifier
  clients = []

  # ## init ##
  # Sets up socket.io
  # ### Args:
  # * _app {Object}_: the express app to integrate socket.io into
  init: (app)->
    io = require('socket.io').listen(app)
    io.set 'log level', 1
    # When a 'connection' event occurs, call _@addClient_
    io.sockets.on 'connection', @addClient

  # ## addClient ##
  # Adds a new client to be notified upon change to watched files
  # ### Args:
  # * _socket {Object}_: Socket object that is generated by a socket.io 
  #   connection event.
  addClient: (socket)->
    clients.push socket
    socket.on "end", ->
      i = clients.indexOf(socket)
      clients.splice i, 1

  # ## notifyClients ##
  # Send a "runTests" message to all connected clients.
  notifyClients: ->
    onEvent "Notifying Browser Test Runner Clients"
    i = 0

    while i < clients.length
      clients[i].emit "runTests", {}
      i++


# Init a new _ClientNotifier_
clientNotifier = new ClientNotifier


# ## createPage ##
# Creates the Pavlov testing page
createPage = ()->

    specPath = config.spec or= "./spec"
    extPath = config.ext or= "./ext"
    libPath = config.testTarget

    ensurePath specPath, ->
      ensurePath extPath, ->
        spec = fs.readdirSync specPath
        spec = _.map spec, (x) ->
            path.join specPath, x
        externals = fs.readdirSync extPath
        externals = _.map externals, (x) ->
            path.join "..", extPath, x
        libs = fs.readdirSync libPath
        libs = _.select libs, (x) ->
            not x.match ///[.]gz[.]/// and not x.match ///[.]min[.]///

        libs = _.map libs, (x) ->
            path.join "..", libPath, x
        list = externals.concat( libs ).concat( spec )

        html = builder.html
        page = html.HTML(
          buildHead( html, list ),
          html.BODY(
            html.H1(
              {"id": "qunit-header"},
              html.H2({"id":"qunit-banner"}),
              html.DIV({"id":"qunit-testrunner-toolbar"}),
              html.H2({"id":"qunit-userAgent"}),
              html.OL({"id":"qunit-tests"})
              )
          )
        )

        writeFileSync "index.html", page.toString(), ->
          onEvent "Pavlov test page generated"
          clientNotifier.notifyClients()


# ## buildHead ##
# Create pavlov results page HEAD by appending script tags for Pavlov, its 
# dependencies, and all Anvil output files
# ### Args:
# * _html {Object}_: DOMBuilder.html object
# * _list {Array}_: list of Anvil output files
buildHead = (html, list)->
  pavlovDir = "pavlov"
  qunitCSS = pavlovDir + "/qunit.css"
  jQueryJS = pavlovDir + "/jquery-1.6.4.min.js"
  qunitJS = pavlovDir + "/qunit.js"
  pavlovJS = pavlovDir + "/pavlov.js"
  socketIo = "/socket.io/socket.io.js"
  scktHook = pavlovDir + "/socketHook.js"

  html.HEAD(
    html.LINK(
      rel: "stylesheet"
      href: qunitCSS
      type: "text/css"
      media: "screen"
    ),
    html.SCRIPT(
      type: "text/javascript"
      src: jQueryJS
    ),
    html.SCRIPT(
      type: "text/javascript"
      src: qunitJS
    ),
    html.SCRIPT(
      type: "text/javascript"
      src: pavlovJS
    ),
    html.SCRIPT(
      type: "text/javascript"
      src: socketIo
    ),
    html.SCRIPT(
      type: "text/javascript"
      src: scktHook
    ),
    # see _buildScripts_ below
    buildScripts html, list
  )

# ## buildScripts ##
# Generate script tags for all the files Anvil has generated
# ### Args:
# * _html {Object}_: DOMBuilder.html object
# * _list {Array}_: list of Anvil output files
buildScripts = ( html, list )->
  # For each member of _list_ add a new script tag to _html_
  _.map list, (x) ->
    html.SCRIPT(
      type: "text/javascript"
      src: x
    )

# ## hostPavlov ##
# Sets up a pavlov page at port 1580
hostPavlov = ()->
    sourceBase = path.normalize path.join __dirname, "..", "ext"

    pavlovPath = path.join global.process.cwd(), "pavlov"
    try
      fs.unlinkSync pavlovPath
    catch error
    finally
      fs.symlinkSync sourceBase, pavlovPath

    app = express.createServer()
    app.use express.bodyParser()
    app.use app.router

    clientNotifier.init app

    app.use "/", express.static( path.resolve(".") )

    app.get "*.coffee", (req, res) ->
        res.header 'Content-Type', 'application/javascript'
        source = fs.readFileSync "." + req.url, "utf8"
        coffee = coffeeScript.compile source, { bare: true }
        res.send coffee

    app.listen 1580