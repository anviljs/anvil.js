// Generated by CoffeeScript 1.3.1
(function() {
  var Anvil, Configuration, FP, Scheduler, defaultLibConfig, defaultSiteConfig, log, scheduler, _;

  _ = require("underscore");

  log = require("./logMock.coffee").log;

  FP = require("./fsMock.coffee").fsProvider;

  Configuration = require("../src/config").configuration;

  Scheduler = require("../src/scheduler.coffee").scheduler;

  scheduler = new Scheduler();

  require("should");

  defaultSiteConfig = {
    "source": "src",
    "style": "style",
    "markup": "markup",
    "output": {
      "source": ["lib", "site/js"],
      "style": ["css", "site/css"],
      "markup": "site/"
    },
    "spec": "spec",
    "ext": "ext",
    "lint": {},
    "uglify": {},
    "cssmin": {},
    "hosts": {
      "/": "site"
    },
    "working": "./tmp"
  };

  defaultLibConfig = {
    "source": "src",
    "output": "lib",
    "spec": "spec",
    "ext": "ext",
    "lint": {},
    "uglify": {},
    "hosts": {
      "/": "spec"
    },
    "working": "./tmp"
  };

  Anvil = (function() {

    Anvil.name = 'Anvil';

    function Anvil() {}

    Anvil.prototype.build = function() {};

    return Anvil;

  })();

  describe("when building in lib without build file", function() {
    var cp, fp;
    fp = new FP();
    cp = new Configuration(fp, scheduler, log);
    return it("should provide default lib configuration", function(done) {
      return cp.configure(["coffee", "./bin/anvil"], function(config) {
        defaultLibConfig.output = {
          "style": "lib",
          "source": "lib",
          "markup": "lib"
        };
        _.isEqual(config, defaultLibConfig).should.be.ok;
        return done();
      });
    });
  });

  describe("when building in site without build file", function() {
    var cp, fp;
    fp = new FP();
    cp = new Configuration(fp, scheduler, log);
    before(function(done) {
      return fp.ensurePath("./site", done);
    });
    return it("should provide default site configuration", function(done) {
      return cp.configure(["coffee", "./bin/anvil"], function(config) {
        _.isEqual(config, defaultSiteConfig).should.be.ok;
        return done();
      });
    });
  });

  describe("when using default build.json file", function() {
    var build, cp, fp;
    fp = new FP();
    build = {
      "source": "thisHereIsMuhSource",
      "output": {
        "style": "lib",
        "source": "lib",
        "markup": "lib"
      },
      "spec": "spec",
      "ext": "ext",
      "lint": {},
      "uglify": {},
      "gzip": {},
      "hosts": {
        "/": "spec"
      },
      "finalize": {},
      "wrap": {}
    };
    before(function(done) {
      var json;
      json = JSON.stringify(build);
      return fp.write("./build.json", json, done);
    });
    cp = new Configuration(fp, scheduler, log);
    return it("should use the loaded file", function(done) {
      return cp.configure(["coffee", "./bin/anvil"], function(config) {
        build.working = "./tmp";
        _.isEqual(config, build).should.be.ok;
        return done();
      });
    });
  });

  describe("when specifying CI", function() {
    var cp, fp;
    fp = new FP();
    cp = new Configuration(fp, scheduler, log);
    return it("should set continuous flag", function(done) {
      return cp.configure(["coffee", "./bin/anvil", "--ci"], function(config) {
        config.continuous.should.be.ok;
        return done();
      });
    });
  });

  describe("when specifying hosting", function() {
    var cp, fp;
    fp = new FP();
    cp = new Configuration(fp, scheduler, log);
    return it("should set host flag", function(done) {
      return cp.configure(["coffee", "./bin/anvil", "--host"], function(config) {
        config.host.should.be.ok;
        return done();
      });
    });
  });

  describe("when lib scaffold is requested", function() {
    var config, cp, fp;
    fp = new FP();
    cp = new Configuration(fp, scheduler, log);
    config = {};
    before(function(done) {
      return cp.configure(["coffee", "./bin/anvil", "--lib", "newlib"], function(cfg) {
        config = cfg;
        return done();
      });
    });
    return describe("once scaffold is complete", function() {
      it("should create source folder", function() {
        return fp.paths["newlib/src"].should.be.ok;
      });
      it("should create lib folder", function() {
        return fp.paths["newlib/lib"].should.be.ok;
      });
      it("should create ext folder", function() {
        return fp.paths["newlib/ext"].should.be.ok;
      });
      it("should create spec folder", function() {
        return fp.paths["newlib/spec"].should.be.ok;
      });
      return it("should create the standard lib build config", function() {
        delete config["host"];
        delete config["continuous"];
        return _.isEqual(config, defaultLibConfig).should.be.ok;
      });
    });
  });

  describe("when site scaffold is requested", function() {
    var config, cp, fp;
    fp = new FP();
    cp = new Configuration(fp, scheduler, log);
    config = {};
    before(function(done) {
      return cp.configure(["coffee", "./bin/anvil", "--site", "newSite"], function(cfg) {
        config = cfg;
        return done();
      });
    });
    return describe("once scaffold is complete", function() {
      it("should create source folder", function() {
        return fp.paths["newSite/src"].should.be.ok;
      });
      it("should create style folder", function() {
        return fp.paths["newSite/style"].should.be.ok;
      });
      it("should create markup folder", function() {
        return fp.paths["newSite/markup"].should.be.ok;
      });
      it("should create lib folder", function() {
        return fp.paths["newSite/lib"].should.be.ok;
      });
      it("should create css folder", function() {
        return fp.paths["newSite/css"].should.be.ok;
      });
      it("should create site/css folder", function() {
        return fp.paths["newSite/site/css"].should.be.ok;
      });
      it("should create site/js folder", function() {
        return fp.paths["newSite/site/js"].should.be.ok;
      });
      it("should create ext folder", function() {
        return fp.paths["newSite/ext"].should.be.ok;
      });
      it("should create spec folder", function() {
        return fp.paths["newSite/spec"].should.be.ok;
      });
      return it("should create the standard site build config", function() {
        return _.isEqual(config, defaultSiteConfig).should.be.ok;
      });
    });
  });

  describe("when requesting new lib build file", function() {
    var cp, fp;
    fp = new FP();
    cp = new Configuration(fp, scheduler, log);
    return it("should create the default lib configuration", function(done) {
      return cp.configure(["coffee", "./bin/anvil", "--libfile", "new"], function(config) {
        return fp.read("new.json", function(content) {
          var obj;
          obj = JSON.parse(content);
          delete obj["host"];
          delete obj["continuous"];
          _.isEqual(obj, defaultLibConfig).should.be.ok;
          return done();
        });
      });
    });
  });

  describe("when requesting new site build file", function() {
    var cp, fp;
    fp = new FP();
    process.argv.push("--sitefile");
    process.argv.push("new");
    cp = new Configuration(fp, scheduler, log);
    return it("should create the default site configuration", function(done) {
      return cp.configure(["coffee", "./bin/anvil", "--sitefile", "new"], function(config) {
        return fp.read("new.json", function(content) {
          var obj;
          obj = JSON.parse(content);
          delete obj["host"];
          delete obj["continuous"];
          _.isEqual(obj, defaultSiteConfig).should.be.ok;
          return done();
        });
      });
    });
  });

  describe("when finalize has string header only", function() {
    var build, cp, expected, fp;
    fp = new FP();
    build = {
      "source": "thisHereIsMuhSource",
      "output": {
        "style": "lib",
        "source": "lib",
        "markup": "lib"
      },
      "spec": "spec",
      "ext": "ext",
      "lint": {},
      "uglify": {},
      "gzip": {},
      "hosts": {
        "/": "spec"
      },
      "finalize": {
        "header": "// this is a test header"
      }
    };
    expected = {
      "source": "thisHereIsMuhSource",
      "output": {
        "style": "lib",
        "source": "lib",
        "markup": "lib"
      },
      "spec": "spec",
      "ext": "ext",
      "lint": {},
      "uglify": {},
      "gzip": {},
      "hosts": {
        "/": "spec"
      },
      "finalize": {
        "source": {
          "header": "// this is a test header",
          "footer": ""
        }
      },
      "working": "./tmp"
    };
    before(function(done) {
      var json;
      json = JSON.stringify(build);
      return fp.write("./build.json", json, done);
    });
    cp = new Configuration(fp, scheduler, log);
    return it("should use the loaded file", function(complete) {
      return cp.configure(["coffee", "./bin/anvil"], function(config) {
        build.working = "./tmp";
        _.isEqual(config, expected).should.be.ok;
        return complete();
      });
    });
  });

  describe("when finalize has a file header only", function() {
    var build, cp, expected, fp;
    fp = new FP();
    build = {
      "source": "thisHereIsMuhSource",
      "output": {
        "style": "lib",
        "source": "lib",
        "markup": "lib"
      },
      "spec": "spec",
      "ext": "ext",
      "lint": {},
      "uglify": {},
      "gzip": {},
      "hosts": {
        "/": "spec"
      },
      "finalize": {
        "header-file": "test.txt"
      }
    };
    expected = {
      "source": "thisHereIsMuhSource",
      "output": {
        "style": "lib",
        "source": "lib",
        "markup": "lib"
      },
      "spec": "spec",
      "ext": "ext",
      "lint": {},
      "uglify": {},
      "gzip": {},
      "hosts": {
        "/": "spec"
      },
      "finalize": {
        "source": {
          "header": "// this is a test header",
          "footer": ""
        }
      },
      "working": "./tmp"
    };
    before(function(done) {
      var json;
      json = JSON.stringify(build);
      return fp.write("./build.json", json, function() {
        return fp.write("test.txt", "// this is a test header", done);
      });
    });
    cp = new Configuration(fp, scheduler, log);
    return it("should use the loaded file", function(complete) {
      return cp.configure(["coffee", "./bin/anvil"], function(config) {
        build.working = "./tmp";
        _.isEqual(config, expected).should.be.ok;
        return complete();
      });
    });
  });

  describe("when wrapping with strings", function() {
    var build, cp, expected, fp;
    fp = new FP();
    build = {
      "source": "thisHereIsMuhSource",
      "output": "lib",
      "spec": "spec",
      "ext": "ext",
      "lint": {},
      "uglify": {},
      "gzip": {},
      "hosts": {
        "/": "spec"
      },
      "wrap": {
        "prefix": "look at my prefix, ya'll",
        "suffix": "bye, ya'll"
      }
    };
    expected = {
      "source": "thisHereIsMuhSource",
      "output": {
        "style": "lib",
        "source": "lib",
        "markup": "lib"
      },
      "spec": "spec",
      "ext": "ext",
      "lint": {},
      "uglify": {},
      "gzip": {},
      "hosts": {
        "/": "spec"
      },
      "wrap": {
        "source": {
          "prefix": "look at my prefix, ya'll",
          "suffix": "bye, ya'll"
        }
      },
      "working": "./tmp"
    };
    before(function(done) {
      var json;
      json = JSON.stringify(build);
      return fp.write("./build.json", json, done);
    });
    cp = new Configuration(fp, scheduler, log);
    return it("should normalize the wrapper", function(complete) {
      return cp.configure(["coffee", "./bin/anvil"], function(config) {
        build.working = "./tmp";
        _.isEqual(config, expected).should.be.ok;
        return complete();
      });
    });
  });

  describe("when using a single name customization", function() {
    var build, cp, fp;
    fp = new FP();
    build = {
      "source": "thisHereIsMuhSource",
      "output": "lib",
      "spec": "spec",
      "ext": "ext",
      "lint": {},
      "uglify": {},
      "gzip": {},
      "hosts": {
        "/": "spec"
      },
      "name": "test/this/is/so/fun/test.js"
    };
    before(function(done) {
      var json;
      json = JSON.stringify(build);
      return fp.write("./build.json", json, done);
    });
    cp = new Configuration(fp, scheduler, log);
    return it("should create any path as part of the name", function(complete) {
      return cp.configure(["coffee", "./bin/anvil"], function(config) {
        var exists;
        exists = fp.pathExists("lib/test/this/is/so/fun");
        exists.should.be.ok;
        return complete();
      });
    });
  });

  describe("when using a multiple name customizations", function() {
    var build, cp, fp;
    fp = new FP();
    build = {
      "source": "thisHereIsMuhSource",
      "output": "lib",
      "spec": "spec",
      "ext": "ext",
      "lint": {},
      "uglify": {},
      "gzip": {},
      "hosts": {
        "/": "spec"
      },
      "name": {
        "one.js": "test/this/is/so/fun/test.js",
        "two.js": "this/is/also/pretty/great/test.js",
        "three.js": "notspecial.js"
      }
    };
    before(function(done) {
      var json;
      json = JSON.stringify(build);
      return fp.write("./build.json", json, done);
    });
    cp = new Configuration(fp, scheduler, log);
    return it("should create all paths as part of the name", function(complete) {
      return cp.configure(["coffee", "./bin/anvil"], function(config) {
        fp.pathExists("lib/test/this/is/so/fun").should.be.ok;
        fp.pathExists("lib/this/is/also/pretty/great").should.be.ok;
        return complete();
      });
    });
  });

}).call(this);
