// Generated by CoffeeScript 1.3.1
(function() {
  var FSMock, FileMock, path, _;

  _ = require("underscore");

  path = require("path");

  FileMock = (function() {

    FileMock.name = 'FileMock';

    function FileMock(name) {
      this.name = name;
      this.delay = 0;
      this.available = true;
    }

    FileMock.prototype["delete"] = function(onComplete) {
      if (this.available) {
        this.content = "";
        return onComplete();
      } else {
        throw new Error("Cannot delete file " + this.name);
      }
    };

    FileMock.prototype.read = function(onContent) {
      var self;
      self = this;
      if (1 === 1) {
        this.available = false;
        return setTimeout(function() {
          onContent(self.content);
          return self.available = true;
        }, self.delay);
      } else {
        throw new Error("Cannot read file " + this.name);
      }
    };

    FileMock.prototype.write = function(content, onComplete) {
      var self;
      self = this;
      if (this.available) {
        return setTimeout(function() {
          self.content = content;
          return onComplete();
        }, self.delay);
      } else {
        throw new Error("Cannot write file " + this.name);
      }
    };

    return FileMock;

  })();

  FSMock = (function() {

    FSMock.name = 'FSMock';

    function FSMock() {
      this.files = {};
      this.paths = {};
    }

    FSMock.prototype.buildPath = function(pathSpec) {
      var fullPath;
      fullPath = pathSpec;
      if (_(pathSpec).isArray()) {
        fullPath = path.join.apply({}, pathSpec);
      }
      return fullPath;
    };

    FSMock.prototype["delete"] = function(filePath, onDeleted) {
      var file;
      filePath = this.buildPath(filePath);
      file = this.files[filePath];
      if (file) {
        delete this.files(filePath);
        return file["delete"](onDeleted);
      } else {
        throw new Error("Cannot delete " + filePath + " - it does not exist");
      }
    };

    FSMock.prototype.ensurePath = function(pathSpec, onComplete) {
      pathSpec = this.buildPath(pathSpec);
      this.paths[pathSpec] = true;
      return onComplete();
    };

    FSMock.prototype.getFiles = function(filePath, onFiles) {
      var files;
      filePath = this.buildPath(filePath);
      files = _.chain(this.files).keys().filter(function(name) {
        return (name.indexOf(filePath)) >= 0;
      }).value();
      return onFiles(files);
    };

    FSMock.prototype.pathExists = function(pathSpec) {
      pathSpec = this.buildPath(pathSpec);
      if (path.extname(pathSpec)) {
        return this.files[pathSpec];
      } else {
        return this.paths[pathSpec];
      }
    };

    FSMock.prototype.transform = function(filePath, transform, outputPath, onComplete) {
      var self;
      self = this;
      filePath = this.buildPath(filePath);
      outputPath = this.buildPath(outputPath);
      return this.read(filePath, function(content) {
        return transform(content, function(newContent, err) {
          return self.write(outputPath, newContent, function() {
            return onComplete(err);
          });
        });
      });
    };

    FSMock.prototype.read = function(filePath, onContent) {
      var file;
      filePath = this.buildPath(filePath);
      file = this.files[filePath];
      if (file) {
        return file.read(function(content) {
          return onContent(content);
        });
      } else {
        throw new Error("Cannot read " + filePath + " - it does not exist");
      }
    };

    FSMock.prototype.write = function(filePath, content, onComplete) {
      var file;
      filePath = this.buildPath(filePath);
      file = this.files[filePath];
      if (!file) {
        file = new FileMock(filePath);
        this.files[filePath] = file;
      }
      return file.write(content, onComplete);
    };

    FSMock.prototype.reset = function() {
      this.files = {};
      return this.paths = {};
    };

    return FSMock;

  })();

  exports.fsProvider = FSMock;

}).call(this);
